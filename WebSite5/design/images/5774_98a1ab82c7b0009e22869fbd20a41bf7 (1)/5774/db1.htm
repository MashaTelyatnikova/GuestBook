<!doctype HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Language" content="ru">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<link rel="stylesheet" href="css.css" type="text/css">
<title>Глава 8. Соединение с БД.</title></head>
<BODY>
<h5><a href="contents.htm"><font size="-1">Оглавление</font></a><FONT SIZE=-1> |
<a href="partlw.htm">Назад</a>
| <a href="db2.htm">Вперёд</a>
| <a href="bklast.htm">Индекс</a></FONT></h5>
<HR><h1>Глава 8<br><A NAME="1023351"></A>Соединение с Базой Данных</h1>
<p><A NAME="1067294"></A>
В этой главе обсуждается использование службы LiveWire Database Service для соединения 
Вашего приложения с реляционными базами данных DB2, Informix, ODBC, Oracle или Sybase. 
Показано, как выбрать наилучшую методологию для Вашего приложения.</p>
<p><A NAME="1073132"></A>В главе имеются следующие разделы:</p>
<ul><LI><A NAME="1072077"></A>
<A HREF="#1068909">Взаимодействие с Базами Данных</A><LI><A NAME="1072081"></A>
<a href="#1036334">Соединение</a><LI><A NAME="1072085"></A>
<A HREF="#1030030">Пулы Соединений с БД</A><LI><A NAME="1073162"></A>
<A HREF="#1070980">Однопоточные и Многопоточные БД</A><LI><A NAME="1072089"></A>
<A HREF="#1070974">Обслуживание Пулов Соединений</A><LI><A NAME="1072093"></A>
<A HREF="#1044987">Индивидуальные Соединения с БД</A></LI></ul>
<H2><A NAME="Interactions with Databases"></A><A NAME="1068909"></A>Взаимодействие с Базами Данных</H2>
<HR><p><A NAME="1069994"></A>
Ваше JavaScript-приложение, запущенное на сервере Netscape Enterprise Server, 
может использовать LiveWire Database Service для доступа к БД серверов Informix, Oracle, Sybase 
и DB2 и серверов, использующих стандарт Open Database Connectivity (ODBC). Ваше 
приложение, запущенное на сервере Netscape FastTrack Server, может получать 
доступ только к БД на серверах, использующих ODBC.</p>
<p>
<A NAME="1068914"></A>
В последующих обсуждениях предполагается, что Вы уже знакомы реляционными БД и Structured Query Language (SQL).</p>
<p>
<A NAME="1049737"></A>
Прежде чем создать приложение JavaScript с использованием LiveWire, база или 
базы данных, к которым Вы планируете подключаться, должны уже существовать на 
сервере БД. Также Вы должны знать их структуру. Если Вы создаёте совершенно 
новое приложение, включающее БД, необходимо создать БД и заполнить её данными (как 
минимум в форме прототипа) до создания приложения.</p>
<p>
<A NAME="1050900"></A>
До того как Вы попытаетесь использовать LiveWire, убедитесь, что Ваша рабочая 
среда сконфигурирована соответственно. О том, как конфигурировать, см. <A HREF="dbconfig.htm#1055577">
Главу 10, "Конфигурирование Вашей Базы Данных."</A> Вы можете также использовать 
приложение-образец <CODE>videoapp</CODE>, описанное в <A HREF="video.htm#1032862">
Главе 13, "Приложения-Образцы Videoapp и Oldvideo,"</A> для изучения некоторых 
возможностей LiveWire.</p>
<p>
<A NAME="1066312"></A>
Обычно для того чтобы взаимодействовать с БД, необходимо выполнить следующие 
общие действия:</p>
<OL><LI><A NAME="1066313"></A>
Использовать объект <CODE>database</CODE> или создать объект <CODE>DbPool</CODE> 
для установки пула соединений БД. Это обычно выполняется на начальной странице 
приложения, если только оно не требует установления специального соединения.</LI><LI><A NAME="1066317"></A>
Подключить пул к БД. Это также обычно выполняется на начальной странице приложения.</LI><LI><A NAME="1066366"></A>
Затребовать соединение из пула. Это выполняется неявно при использовании 
объекта <CODE>database</CODE> или явно - при использовании метода <CODE>connection</CODE> 
объекта <CODE>DbPool</CODE>.</LI><LI><A NAME="1066322"></A>
Если Вы изменяете информацию в БД, начинается транзакция. Транзакции БД 
обсуждаются в разделе <A HREF="db2.htm#1040958">"Обслуживание Транзакций "</A>.</LI><LI><A NAME="1066323"></A>
Создать курсор или вызывать хранимую процедуру для работы с информацией из БД. 
Здесь может происходить вывод результатов выполнения запроса или обновление 
содержимого БД. Закройте открытый курсор, результирующий набор или хранимую 
процедуру после окончания их использования. Курсоры обсуждаются в разделе <A HREF="db2.htm#1030418">"Обслуживание 
Результатов Выполнения Запроса с Помощью Курсоров"</A>; хранимые процедуры обсуждаются в 
разделе <A HREF="db2.htm#1030702">"Вызов Хранимых Процедур"</A>.</LI><LI><A NAME="1066355"></A>
Подтвердить транзакцию или выполнить откат.</LI><LI><A NAME="1066356"></A>
Освободить соединение с БД (если используете объекты <CODE>Connection</CODE>).</LI></OL>
<p><A NAME="1066543"></A>В этой главе обсуждаются первые три пункта действий. В <A HREF="db2.htm#1064023">
Главе 9, "Работа с БД&quot;</A>, обсуждаются остальные шаги.</p>
<H2><A NAME="Approaches to Connecting"></A><A NAME="1036334"></A>Соединение. Подходы.</H2>
<HR><p><A NAME="1035940"></A>
Есть два основных способа соединения с БД с помощью сервиса LiveWire Database Service. 
Это объекты <CODE>DbPool</CODE> и <CODE>Connection</CODE>, либо объект <CODE>database</CODE>.</p>
<h4><A NAME="HeadRunIn;"></A><A NAME="1036064"></A>Соединение с Помощью Объектов DbPool и Connection</h4>
<hr><p><A NAME="1036101"></A>При этом подходе Вы создаёте пул соединений для работы 
с реляционной БД. Вы создаёте экземпляр класса <CODE>DbPool</CODE>,а затем 
получаете доступ к объектам <CODE>Connection</CODE> через этот объект <CODE>DbPool</CODE>. 
Объекты <CODE>DbPool</CODE> и <CODE>Connection</CODE> распределяют между собой 
работу по соединению с БД и обслуживанию набора соединений и доступ к БД через соединение.</p>
<p><A NAME="1036151"></A>Это весьма гибкий подход. Ваше приложение может иметь несколько пулов соединений, 
каждый со своей собственной конфигурацией БД и пользователя. Каждый пул может 
иметь несколько соединений при такой конфигурации. Это даёт одновременный доступ 
к нескольким БД или к одной БД из нескольких бюджетов. Вы можете также 
ассоциировать пул непосредственно с приложением, а не с отдельным клиентским 
запросом, и иметь таким образом транзакции, захватывающие несколько клиентских 
запросов. Это ассоциирование выполняется путём присвоения пула свойству 
объекта <CODE>project</CODE> и удаления этого присвоения после окончания работы с пулом.</p>
<h4><A NAME="HeadRunIn;"></A><A NAME="1035941"></A>Соединение с Объектом database</h4><hr>
<p><A NAME="1036105"></A>При этом подходе Вы используете предопределённый объект <CODE>database</CODE> 
для соединения с БД при наличии единственной конфигурации соединения БД и 
пользователя. Объект <CODE>database</CODE> выполняет все действия по работе с БД. 
Можно представить этот объект как <CODE>database</CODE> единый пул соединений с БД.</p>
<p><A NAME="1036155"></A>Этот подход несколько проще, так как используется только один объект <CODE>database</CODE>, 
а не несколько объектов <CODE>DbPool</CODE> и <CODE>Connection</CODE>. Однако 
при этом теряется гибкость первого подхода. Если Вы используете только объект <CODE>database</CODE> 
и хотите соединиться с разными БД или разными бюджетами, Вы обязаны отключиться 
от одной конфигурации, для того чтобы подключиться к другой. Также, при 
использовании объекта <CODE>database</CODE>, одна транзакция не может захватить 
несколько клиентских запросов, а соединения с несколькими БД-источниками не могут быть установлены одновременно.</p>
<p><A NAME="1057649"></A>Как описано в последующих разделах, Вы должны ответить на два основных вопроса, 
когда решаете, как устанавливать соединения с БД:</p>
<ul><LI><A NAME="1057662"></A>
Сколько конфигураций и соединений БД и пользователей Вам нужно?</LI><LI><A NAME="1057675"></A>
Будет ли одно соединение захватывать несколько клиентских запросов?</LI></ul><p><A NAME="1072941"></A>
В таблице резюмируется, как ответ на эти вопросы влияет на установку и 
обслуживание пула соединений с БД и отдельных соединений. В последующих разделах 
обсуждаются детали этих вариантов.</p>
<A NAME="1073036"></A><h5><A NAME="1072948"></A>
Таблица 8.1&nbsp; Рассмотрение создания пулов БД</h5>
<TABLE BORDER="2" CELLPADDING=5 width="762"><TR>
<TH VALIGN=baseline ALIGN=left width="138"><A NAME="1072960"></A>
Сколько конфигураций БД?<TH VALIGN=baseline ALIGN=left width="98"><A NAME="1072962"></A>
Где соединение с пулом?<TH VALIGN=baseline ALIGN=left width="99"><A NAME="1072964"></A>
Где отключение пула?<TH VALIGN=baseline ALIGN=left width="87"><A NAME="1072966"></A>
Какой объект(ы) содержит пул?<TH VALIGN=baseline ALIGN=left width="115"><A NAME="1072968"></A>
Должен ли Ваш код хранить пул и соединение?<TH VALIGN=baseline ALIGN=left width="135"><A NAME="1072970"></A>
Как Ваш код хранит пул и соединение в объекте <CODE>project</CODE>?<TR>
<TD VALIGN=baseline ALIGN=left width="138"><P><A NAME="1072972"></A>
1, используется всеми клиентами</P>
<TD VALIGN=baseline ALIGN=left width="98"><P><A NAME="1072974"></A>
Начальная страница приложения</P><TD VALIGN=baseline ALIGN=left width="99"><P><A NAME="1072976"></A>
Нигде</P><TD VALIGN=baseline ALIGN=left width="87"><P><A NAME="1072978"></A>
<CODE>database</CODE></P><TD VALIGN=baseline ALIGN=left width="115"><P><A NAME="1072980"></A>
Нет</P><TD VALIGN=baseline ALIGN=left width="135"><P><A NAME="1072982"></A>
--</P><TR><TD VALIGN=baseline ALIGN=left width="138"><P><A NAME="1072984"></A>
1, используется всеми клиентами</P><TD VALIGN=baseline ALIGN=left width="98"><P><A NAME="1072986"></A>
Начальная страница приложения</P><TD VALIGN=baseline ALIGN=left width="99"><P><A NAME="1072988"></A>
Нигде</P><TD VALIGN=baseline ALIGN=left width="87"><P><A NAME="1072990"></A>
<CODE>1 DbPool</CODE> object</P><TD VALIGN=baseline ALIGN=left width="115"><P><A NAME="1072992"></A>
Да</P><TD VALIGN=baseline ALIGN=left width="135"><P><A NAME="1072994"></A>
<CODE>DbPool</CODE>: Именованное свойство;</P><P><A NAME="1072995"></A>
<CODE>Connection</CODE>: 1 массив</P>
<TR><TD VALIGN=baseline ALIGN=left width="138"><P><A NAME="1072997"></A>
Фиксированный набор, используется всеми клиентами</P>
<TD VALIGN=baseline ALIGN=left width="98"><P><A NAME="1072999"></A>
Начальная страница приложения</P><TD VALIGN=baseline ALIGN=left width="99"><P><A NAME="1073001"></A>
Нигде</P><TD VALIGN=baseline ALIGN=left width="87"><P><A NAME="1073003"></A>
N <CODE>DbPool</CODE>-объектов</P><TD VALIGN=baseline ALIGN=left width="115"><P><A NAME="1073005"></A>
Да</P><TD VALIGN=baseline ALIGN=left width="135"><P><A NAME="1073007"></A>
<CODE>DbPool</CODE>: Именованное свойство;</P><P><A NAME="1073008"></A>
<CODE>Connection</CODE>: N массивов</P>
<TR><TD VALIGN=baseline ALIGN=left width="138"><P><A NAME="1073010"></A>
Отдельный пул для каждого клиента</P>
<TD VALIGN=baseline ALIGN=left width="98"><P><A NAME="1073012"></A>
Клиентская страница запроса</P><TD VALIGN=baseline ALIGN=left width="99"><P><A NAME="1073017"></A>
Зависит от <A HREF="#1073016"><SUP>1</SUP></P>
<TD VALIGN=baseline ALIGN=left width="87"><P><A NAME="1073019"></A>
Многие объекты <CODE>DbPool</CODE></P>
<TD VALIGN=baseline ALIGN=left width="115"><P><A NAME="1073021"></A>
Только если соединение захватывает клиентские запросы</P>
<TD VALIGN=baseline ALIGN=left width="135"><P><A NAME="1073023"></A>
<CODE>DbPool</CODE>: 1 массив<CODE>;</CODE></P><P><A NAME="1073024"></A>
<CODE>Connection</CODE>: 1 массив</P></TABLE>
<TABLE><TR><TD><SUP>1</SUP>
<A NAME="1073016"></A>
<p>Если отдельное соединение не захватывает клиентские запросы, Вы можете 
соединять и отсоединять пул на каждой странице, в которой нужн&#x00f3; соединение. 
В этом случае пул не сохраняется в промежутке времени между запросами. Если 
отдельное соединение захватывает клиентские запросы, соединяйте на первой 
клиентской странице, которой необходимо соединение, и отсоединяйте на 
последней такой странице. Это может привести к появлению незанятых соединений/idle, 
и Ваше приложение должно будет обработать такую ситуацию.</TABLE><H2>
<A NAME="Database Connection Pools"></A><A NAME="1030030"></A>
Пулы Соединений с БД</H2><HR><p><A NAME="1036570"></A>
Если Вы хотите использовать объект <CODE>database</CODE>, Вам не нужно создавать 
его. Это предопределённый объект, предоставляемый машиной выполнения JavaScript. 
Если Вам нужны дополнительные возможности класса <CODE>DbPool</CODE>, Вы 
создаёте экземпляр класса <CODE>DbPool</CODE> и соединяете этот объект с 
конкретной БД, которая создаёт пул соединений.</p>
<p>
<A NAME="1036461"></A>
Вы можете создать общий <CODE>DbPool</CODE>-объект и специфицировать позднее 
информацию соединения (используя метод <CODE>connect</CODE>), или можете 
специфицировать информацию соединения при создании пула. Общий <CODE>DbPool</CODE>-объект 
не имеет никаких доступных соединений в момент его создания. Исходя из этого, 
Вам может понадобиться установить соединение при создании этого объекта. Если Вы 
используете объект <CODE>database</CODE>, Вы всегда обязаны устанавливать 
соединение путём вызова метода <CODE>database.connect</CODE>.</p>
<PRE><A NAME="1043087"></A>connect (dbtype, serverName, userName, password, <br>&nbsp;&nbsp;&nbsp;databaseName, maxConnections, commitFlag);</PRE>
<p><A NAME="1036612"></A>
При создании соединения Вы можете специфицировать следующую информацию, либо при 
создании <CODE>DbPool</CODE>-объекта, либо при вызове метода <CODE>connect</CODE> 
объекта <CODE>DbPool</CODE> или <CODE>database</CODE>:</A></p>
<ul><LI><A NAME="1047871"></A>
<CODE>dbtype</CODE>: Тип БД. Обязан быть <CODE>"DB2"</CODE>, <CODE>"INFORMIX"</CODE>, <CODE>"ODBC"</CODE>, <CODE>"ORACLE"</CODE> 
или <CODE>"SYBASE"</CODE>. (Для приложений, запущенных на сервере Netscape FastTrack Server, 
обязан быть <CODE>"ODBC"</CODE>.)</LI><LI><A NAME="1072832"></A>
<CODE>serverName</CODE>: Имя сервера БД, с которым устанавливается соединение. 
Имя сервера обычно назначается при установке БД. В случае сомнений, узнайте у 
администратора БД или системы.<LI><A NAME="1072838"></A>
<CODE>username</CODE>: Имя пользователя, соединяющегося с БД.</LI><LI><A NAME="1030044"></A><CODE>password</CODE>: 
Пароль пользователя.</LI><LI><A NAME="1037700"></A>
<CODE>databaseName</CODE>: Имя БД на данном сервере, с которой устанавливается 
соединение. Если Ваш сервер баз данных поддерживает множество БД на одном 
сервере, предоставьте имя используемой БД. Если предоставлена пустая строка, 
производится соединение с БД по умолчанию. Для Oracle, ODBC и DB2 Вы всегда 
обязаны предоставлять пустую строку.</LI><LI><A NAME="1037701"></A>
<CODE>maxConnections</CODE>: (Optional/Необязательный Параметр) Допустимое 
количество соединений в пуле БД. Помните, что клиентская лицензия Вашей БД, 
возможно, специфицирует максимальное количество соединений. Не устанавливайте 
этот параметр в число, превышающее количество, допустимое по лицензии. Если Вы 
не предоставляете этот параметр для объекта <CODE>DbPool</CODE>, он имеет 
значение 1. Если Вы не предоставляете этот параметр для объекта <CODE>database</CODE>, 
его значением будет то, что Вы специфицировали в Application Manager как 
значение для Built-in Maximum Database Connections/Встроенное Значение 
Максимального Количества Соединений с БД, когда устанавливали приложение. (См. <A HREF="appdev.htm#1043531">"Установка 
Нового Приложения&quot;</A>). См. в разделе <A HREF="#1070980">"Однопоточные и 
Многопоточные БД&quot;</A> о том, что Вы должны предусмотреть при установке этого 
параметра.</LI><LI><A NAME="1030048"></A>
<CODE>commitflag</CODE>: (Необязательный Параметр) Булево значение, 
указывающее, подтвердить ли открытую транзакцию или выполнить её откат при 
закрытии соединения. Специфицируйте <CODE>true</CODE> для подтверждения 
открытой транзакции и <CODE>false</CODE> - для выполнения отката. Если этот 
параметр Вами не предоставлен для объекта <CODE>DbPool</CODE>, его значением 
будет <CODE>false</CODE>. Если этот параметр не предоставлен для объекта <CODE>database</CODE>, 
значением параметра будет <CODE>true</CODE>.</LI></ul><p><A NAME="1030050"></A>
Например, следующий оператор создаёт новый пул БД из 5 соединений с БД Oracle. В 
этом пуле неподтверждённые транзакции откатываются:</p>
<PRE><A NAME="1030051"></A>pool = new DbPool ("ORACLE", "myserver1", "ENG", "pwd1", "", 5);</PRE>
<p><A NAME="1030052"></A>
Приложение-образец <CODE>dbadmin</CODE> позволяет Вам экспериментировать с 
соединениями с различными БД как разным пользователям.</p>
<p><A NAME="1060854"></A>
Для многих приложений Вы, возможно, захотите выполнять совместное использование 
набора соединений несколькими клиентами, или чтобы соединение захватывало 
несколько клиентских запросов. В этих случаях Вы должны устанавливать соединение 
на начальной странице Вашего приложения. Это позволит исключить возможные 
проблемы в тех случаях, когда отдельные клиенты выполняют совместные соединения с БД.</p>
<p><A NAME="1054303"></A>Однако для некоторых приложений каждый клиент должен выполнять своё собственное 
соединение. Как сказано в разделе <A HREF="#1044823">"Совместное Использование 
Массива Пулов Соединений,"</A> клиенты могут совместно использовать объекты. 
Если это так, убедитесь, что блокировки используются для управления совместным 
использованием данных, как указано в разделе <A HREF="sessmgmt.htm#1012796">"Безопасное 
Использование Объектов с Помощью Блокировки&quot;</A>.</p>
<p><A NAME="1054470"></A>В следующей таблице показаны методы объектов <CODE>DbPool</CODE> и <CODE>database</CODE> 
для обслуживания пула соединений. (Объект <CODE>database</CODE> использует 
другие методы, рассмотренные ранее, для работы с соединением с БД.)</p>
<A NAME="1073090"></A><h5><A NAME="1054477"></A>
Таблица 8.2 Методы объектов&nbsp;<CODE>DbPool</CODE> и <CODE>database</CODE> для 
обслуживания пулов соединений</h5>
<TABLE BORDER="2" CELLPADDING=5><TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1054481"></A>
<CODE>connect</CODE></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1054483"></A>
Соединяет пул с определённой конфигурацией БД и пользователя.</P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1054485"></A>
<CODE>connected</CODE></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1054487"></A>
Проверяет, соединён ли пул и все его соединения с базой данных.</P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1054489"></A>
<CODE>connection</CODE></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1054491"></A>
(Только <CODE>DbPool</CODE>) Запрашивает доступный <CODE>Connection</CODE>-объект из пула.</P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1054493"></A>
<CODE>disconnect</CODE></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1054495"></A>
Отсоединяет все соединения пула от БД.</P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1054505"></A>
<CODE>majorErrorCode</CODE></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1054507"></A>
Главный код ошибки, возвращаемый сервером БД или ODBC.</P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1054510"></A>
<CODE>majorErrorMessage</CODE></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1054512"></A>
Главное сообщение об ошибке, возвращаемое сервером БД или ODBC.</P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1054515"></A>
<CODE>minorErrorCode</CODE></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1054517"></A>
Вторичный код ошибки, возвращаемый библиотекой продавца.</P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1054520"></A>
<CODE>minorErrorMessage</CODE></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1054522"></A>
Вторичное сообщение об ошибке, возвращаемое библиотекой продавца.</P></TABLE>
<H2><A NAME="Single-Threaded and Multithreaded Databases"></A><A NAME="1070980"></A>
Однопоточные и Многопоточные Базы Данных</H2><HR><p><A NAME="1070999"></A>
LiveWire поддерживает многопоточный доступ к БД. То есть она поддерживает 
наличие более чем одного потока доступа к одной БД в единицу времени. Отсюда 
ясно, для чего нужен пул соединений с более чем одним соединением. Однако 
библиотеки БД некоторых производителей не являются многопоточными.
Для таких БД не имеет значения, сколько соединений имеется в Вашем пуле, так как 
только одно соединение может устанавливаться с БД в единицу времени.</p>
<p><A NAME="1073631"></A>В этой таблице дан список клиентских библиотек баз данных, которые являются 
многопоточными на указанных платформах.</p>
<h5><A NAME="1073635"></A>Таблица 8.3&nbsp; Многопоточность БД-клиентов на разных платформах</h5>
<TABLE BORDER="2" CELLPADDING=5>
<TR><TH VALIGN=baseline ALIGN=left><A NAME="1073647"></A>
<TH VALIGN=baseline ALIGN=left><A NAME="1073649"></A>
Sybase<TH VALIGN=baseline ALIGN=left><A NAME="1073651"></A>Informix<TH VALIGN=baseline ALIGN=left><A NAME="1073653">Oracle<TH VALIGN=baseline ALIGN=left><A NAME="1073655"></A>
DB2<TH VALIGN=baseline ALIGN=left><A NAME="1073660"></A>ODBC<A HREF="#1073659"><SUP>1</SUP></A><TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1073662"></A>
NT</P><TD VALIGN=baseline ALIGN=left><P><A NAME="1073664"></A>
Есть</P><TD VALIGN=baseline ALIGN=left><P><A NAME="1073666"></A>
Есть</P><TD VALIGN=baseline ALIGN=left><P><A NAME="1073668"></A>
Есть</P><TD VALIGN=baseline ALIGN=left><P><A NAME="1073670"></A>
Есть</P><TD VALIGN=baseline ALIGN=left><P><A NAME="1073672"></A>
Есть</P><TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1073674"></A>
Sun Solaris</P><TD VALIGN=baseline ALIGN=left><P><A NAME="1073676"></A>
Есть</P><TD VALIGN=baseline ALIGN=left><P><A NAME="1073678"></A>
Есть</P><TD VALIGN=baseline ALIGN=left><P><A NAME="1073680"></A>
Есть</P><TD VALIGN=baseline ALIGN=left><P><A NAME="1073682"></A>
Нет</P><TD VALIGN=baseline ALIGN=left><P><A NAME="1073684"></A>
Нет</P><TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1073686"></A>
HP-UX</P><TD VALIGN=baseline ALIGN=left><P><A NAME="1073688"></A>
Есть</P><TD VALIGN=baseline ALIGN=left><P><A NAME="1073690"></A>
Есть</P><TD VALIGN=baseline ALIGN=left><P><A NAME="1073692"></A>
Нет</P><TD VALIGN=baseline ALIGN=left><P><A NAME="1073694"></A>
Нет</P><TD VALIGN=baseline ALIGN=left><P><A NAME="1073696"></A>
Нет</P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1073698"></A>
IBM AIX</P><TD VALIGN=baseline ALIGN=left><P><A NAME="1073700"></A>
Есть</P><TD VALIGN=baseline ALIGN=left><P><A NAME="1073702"></A>
Есть</P><TD VALIGN=baseline ALIGN=left><P><A NAME="1073704"></A>
Нет</P><TD VALIGN=baseline ALIGN=left><P><A NAME="1073706"></A>
Есть</P><TD VALIGN=baseline ALIGN=left><P><A NAME="1073708"></A>
Нет</P><TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1073710"></A>
SGI IRIX</P><TD VALIGN=baseline ALIGN=left><P><A NAME="1073712"></A>
Нет</P><TD VALIGN=baseline ALIGN=left><P><A NAME="1073714"></A>
Нет</P><TD VALIGN=baseline ALIGN=left><P><A NAME="1073716"></A>
Нет</P><TD VALIGN=baseline ALIGN=left><P><A NAME="1073718"></A>
Не поддерживается</P><TD VALIGN=baseline ALIGN=left><P><A NAME="1073720"></A>
Нет</P><TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1073722"></A>
Digital Unix</P><TD VALIGN=baseline ALIGN=left><P><A NAME="1073724"></A>
Есть</P><TD VALIGN=baseline ALIGN=left><P><A NAME="1073726"></A>
Есть</P><TD VALIGN=baseline ALIGN=left><P><A NAME="1073728"></A>
Нет</P><TD VALIGN=baseline ALIGN=left><P><A NAME="1073730"></A>
Не поддерживается</P><TD VALIGN=baseline ALIGN=left><P><A NAME="1073732"></A>
Не поддерживается</P></TABLE>
<TABLE><TR><TD><SUP>1</SUP><A NAME="1073659"></A><p>Все многопоточные тесты для ODBC 
были сделаны на MS SQL Server. Если Вы используете другой драйвер ODBC, 
узнайте у производителя, является ли драйвер многопоточным.</TABLE>
<h4><A NAME="Head2;"></A><A NAME="1071334"></A>Советы</h4><hr><p><A NAME="1073769"></A>
Эти указания являются критичными для однопоточного доступа. Однако Вы должны 
думать об этом даже тогда, когда используете БД с многопоточным доступом.<br>
<A NAME="1073806"></A>Однопоточная библиотека БД может иметь существенные 
ограничения производительности. Поскольку только один поток имеет доступ к БД в 
единицу времени, все прочие потоки обязаны ждать, когда первый поток освободит 
соединение с БД, прежде чем один из них сможет получить доступ к БД. Если 
доступа ожидают одновременно несколько потоков, каждому придётся ожидать довольно долго.<br>
При разработке доступа к БД Вы должны предусмотреть следующее:</p>
<ul><LI><A NAME="1071154"></A>
Старайтесь максимально сократить взаимодействие с БД.</LI><p><A NAME="1071190"></A>
Каждый поток обязан ждать окончания работы другого потока. Чем короче время 
взаимодействия с БД, тем меньше ожидание.<LI><A NAME="1071181"></A>
Всегда освобождайте соединение сразу и закрывайте открытые курсоры и хранимые процедуры.</LI><br>
<A NAME="1071247"></A>Вы должны делать это в любом случае. Но в случае с однопоточной БД это 
становится абсолютно необходимым для предотвращения ожидания.<LI><A NAME="1071245"></A>
Всегда используйте явное управление транзакциями.</LI><br>
<A NAME="1071155"></A>Тогда будет ясно, когда завершена работа с соединением.<LI><A NAME="1071212"></A>
Не держите соединение открытым, ожидая ввода от пользователя.</LI><br>
<A NAME="1071145"></A>Пользователи не всегда завершают начатое. Если пользователь сделал переход от 
Вашего приложения, когда соединение с БД открыто, система не должна заботиться 
об освобождении этого соединения. Если&nbsp; только Вы не реализуете схему с 
запросом незанятых соединений (как указано в разделе <A HREF="#1051342">"Запрос 
Незанятого Соединения"</A>), такое соединение может оказаться связанным на 
достаточно продолжительное время, ограничивая таким образом доступ других 
пользователей к БД.<LI><A NAME="1071292"></A>
Не оставляйте курсоры и транзакции открытыми для нескольких страниц Вашего приложения.</LI><br>
<A NAME="1071293"></A>Когда взаимодействие с БД захватывает несколько страниц приложения, риск того, 
что пользователь не завершит транзакцию, значительно возрастает.</ul><p><A NAME="1073972"></A>
Ограничения на использование транзакций для клиентских библиотек БД, которые не являются многопоточными:</p>
<ul><LI><A NAME="1073973"></A>
Если у Вас однопоточные библиотеки и Вы используете два соединения 
одновременно на одной странице с БД одного типа, Вы можете получить deadlock/мёртвую 
блокировку, если выполняете явные транзакции (то есть такие, которые 
начинаются с использования beginTransaction). Это может случиться с 
транзакциями на одной странице.</LI><LI><A NAME="1073974"></A>
При многостраничных транзакциях с однопоточными библиотеками только одно 
соединение с БД может быть активным в единицу времени, или Вы получите мёртвую 
блокировку, как описано в предыдущем пункте.</LI><LI><A NAME="1073975"></A>
Если клиентская библиотека БД не является многопоточной, только одна 
соединение с БД может быть активным в единицу времени. Хотя Вы не обязаны 
изменять свой код для обработки такой ситуации, Вы должны знать, что без 
многопоточной клиентской библиотеки БД Вы не получите выигрыша в 
производительности, даваемого многопоточными библиотеками при наличии 
нескольких одновременных соединений.</LI><LI><A NAME="1073976"></A>
Некоторые библиотеки БД не являются многопоточными. По этой причине, если Вы 
используете объекты <CODE>database()</CODE> или DbPool(), Вы обязаны 
установить максимальное допустимое количество соединений с БД в Вашем 
приложении большим, чем количество клиентов, которые, как Вы предполагаете, 
будут использовать Ваше приложение. Иначе некоторые клиенты не смогут 
установить соединение с БД, и их приложения зависнут.</LI></ul><H2>
<A NAME="Managing Connection Pools"></A><A NAME="1070974"></A>
Обслуживание Пулов Соединений</H2><hr><p><A NAME="1030064"></A>
В любой данный момент времени соединённый объект <CODE>DbPool</CODE> или <CODE>database</CODE> 
и все соединения пула ассоциированы с определённой конфигурацией базы данных. То 
есть всё, что находится в пуле, соединено с определённым сервером БД как 
отдельный пользователь с отдельным паролем и с определённой БД.</p>
<p>
<A NAME="1030065"></A>
Если Ваше приложение всегда использует одну конфигурацию, то можно использовать 
единственный объект <CODE>DbPool</CODE> или использовать объект <CODE>database</CODE> 
и соединяться однократно. В этом случае Вы должны выполнить соединение на 
начальной странице Вашего приложения.</p>
<p>
<A NAME="1054705"></A>
Если Вашему приложению требуется несколько конфигураций, или потому что оно 
обязано соединяться с несколькими БД, или с одной БД, но с разными 
пользователями, или и то, и другое, Вам необходимо определить, как обслуживать 
эти конфигурации.</p>
<p>
<A NAME="1054822"></A>
Если Вы используете объект <CODE>database</CODE> и несколько соединений, то 
выбора у Вас нет. Вы обязаны соединяться, отсоединяться и повторно соединяться с 
объектом <CODE>database</CODE> каждый раз, когда Вам нужно изменить что-либо в 
конфигурации. Вы делаете это под управлением клиентских запросов. В этой 
ситуации убедитесь, что используются блокировки, как указано в разделе <A HREF="sessmgmt.htm#1012796">"Совместное 
Использование Объектов с Блокировкой,"</A> чтобы получать исключительный доступ 
к объекту <CODE>database</CODE>. Иначе другой клиентский запрос может отключить 
объект до того, как текущий клиентский запрос закончит с ним работу. Хотя Вы и 
можете использовать объект <CODE>database</CODE> таким образом, лучше будет 
всё-таки использовать объекты <CODE>DbPool</CODE>.</p>
<p>
<A NAME="1054826"></A>
Если Вы используете объекты <CODE>DbPool</CODE> и несколько конфигураций, Вы 
также должны соединяться, отсоединяться и повторно соединяться с объектом <CODE>DbPool</CODE>. 
Однако с объектами <CODE>DbPool</CODE> у Вас появится больше возможностей. Вы 
можете создавать столько пулов, сколько нужно, и ставить их под контроль объекта <CODE>project</CODE>. (См. 
в <A HREF="sessmgmt.htm#1036383">Главе 6, "Обслуживание Сессий&quot;</A> информацию 
об объекте <CODE>project</CODE>.) Использование нескольких пулов более 
эффективно и обычно надёжнее, чем многократное использование единственного пула (как 
с объектом <CODE>database</CODE> , так и с единственным объектом <CODE>DbPool</CODE>).</p>
<p>
<A NAME="1054995"></A>
При определении того, как обслуживать пулы, Вы обязаны учитывать два фактора: ко 
скольки конфигурациям будут иметь доступ пулы и нужно ли будет одному соединению 
захватывать несколько клиентских запросов. Если у Вас небольшое количество 
возможных конфигураций, Вы можете создать отдельные пулы для каждой. В разделе <A HREF="#1043363">"Совместное 
Использование Фиксированного Набора Пулов Соединений"</A> обсуждается этот 
подход.</p>
<p>
<A NAME="1055473"></A>
Если у Вас имеется очень большое или заранее не известное количество 
конфигураций (например, если все пользователи БД получают свои индивидуальные ID), 
нужно предусмотреть два варианта. Если одного соединения достаточно для 
выполнения одного клиентского запроса, Вы можете создавать отдельные пулы на 
клиентской странице.</p>
<p>
<A NAME="1056407"></A>
Однако иногда соединение должно захватывать несколько клиентских запросов (например, 
если одна транзакция в БД захватывает несколько клиентских запросов). Возможно 
также, что Вы просто не хотите повторно соединяться с БД на каждой странице 
приложения. Если это так, Вы можете создать массив пулов, который используется 
совместно. В разделе <A HREF="#1044823">"Совместное Использование Массива Пулов 
Соединений"</A> обсуждается этот подход.</p>
<p>
<A NAME="1056411"></A>
Независимо от используемого подхода, если Вам больше не нужно отдельное 
соединение в пуле, зачистите ресурсы, используемые этим соединением, чтобы оно 
стало доступным для других пользователей. Чтобы выполнить это, закройте все 
открытые курсоры, хранимые процедуры и результирующие наборы. Верните соединение 
обратно в пул. (Вы не должны освобождать соединение, если используете объект <CODE>database</CODE>.)</p>
<p>
<A NAME="1073262"></A>
Если Вы не освободили соединение, то при попытке отсоединить пул система будет 
ожидать, перед тем как реально отсоединиться, возникновения одного из двух 
условий:</p>
<ul><LI><A NAME="1073263"></A>Вы освобождаете все соединения<LI><A NAME="1073264"></A>
  Соединения выходят за пределы области видимости и убираются сборщиком мусора</LI>
</ul><p><A NAME="1073265"></A>
Если Вы создаёте отдельные пулы БД для каждого пользователя, убедитесь, что пул 
отсоединён, до того как закончить с ним работу. О курсорах см <A HREF="db2.htm#1030418">"Манипуляции 
с Результатами Выполнения Запросов с Помощью Курсоров&quot;</A>. О хранимых 
процедурах и результирующих наборах см. <A HREF="db2.htm#1030702">"Вызов 
Хранимых Процедур&quot;</A>.</p>
<h4>
<A NAME="Head2;"></A><A NAME="1043363"></A>Совместное Использование 
Фиксированного Набора Пулов Соединений</h4>
<hr><p>
<A NAME="1030075"></A>
Часто в приложении небольшой набор пулов соединений используется всеми 
пользователями данного приложения. Например, Вашему приложению нужно соединяться 
с тремя различными БД или с одной БД, которая использует 4 пользовательских ID, 
соответствующих 4 разным департаментам. Если у вас имеется небольшой набор 
возможных конфигураций соединения, Вы можете создать отдельный пул для каждой 
конфигурации. Для этого используйте объекты <CODE>DbPool</CODE>.</p>
<p>
<A NAME="1030076"></A>
Тогда необходимо, чтобы пул работал в течение всего периода существования 
приложения, а не просто в течение периода существования клиента или отдельного 
клиентского запроса. Вы можете реализовать это, создав каждый пул БД как 
свойство объекта <CODE>project</CODE>. Например, начальная страница приложения 
может содержать эти операторы:</p>
<PRE><A NAME="1066173"></A>project.engpool = new DbPool ("ORACLE", "myserver1", "ENG",<br>&nbsp;&nbsp;&nbsp;"pwd1", "", 5, true);<br>project.salespool = new DbPool ("INFORMIX", "myserver2", "SALES",<br>&nbsp;&nbsp;&nbsp;"pwd2", "salsmktg", 2);<br>project.supppool = new DbPool ("SYBASE","myserver3","SUPPORT",<br>&nbsp;&nbsp;&nbsp;"pwd3", "suppdb", 3, false);</PRE>
<p><A NAME="1030080"></A>
Эти операторы создают три пула для различных групп пользователей приложения.<br>
Пул <CODE>project.eng</CODE> содержит 5 соединений Oracle и подтверждает любую 
неподтверждённую транзакцию при высвобождении соединения обратно в пул.<br>
Пул <CODE>project.sales</CODE> имеет два соединения Informix и откатывает любую 
неподтверждённую транзакцию при окончании соединения.<br>
Пул<CODE> project.supp</CODE> имеет три соединения Sybase и откатывает любую 
неподтверждённую транзакцию при окончании соединения.</p>
<p>
<A NAME="1037926"></A>
Вы должны создавать такой пул как часть начальной страницы приложения. Эта 
страница выполняется только при старте приложения. На страницах, доступных 
пользователям, Вы не создаёте пул и не изменяете соединение. Вместо этого эти 
страницы определяют, к какой группе принадлежит текущий пользователь, и 
используют уже установленное соединение из соответствующего пула. Например, в 
следующем коде определяется, какую БД использовать (на основе значения свойства <CODE>userGroup</CODE> 
объекта <CODE>request</CODE>), в БД ищется некоторая информация, которая 
выводится пользователю, а затем соединение освобождается:</p>
<PRE><A NAME="1065402"></A>if (request.userGroup == "SALES") {<br>&nbsp;&nbsp;&nbsp;salesconn = project.salespool.connection("A sales connection");<br>&nbsp;&nbsp;&nbsp;salesconn.SQLTable ("select * from dept");<br>&nbsp;&nbsp;&nbsp;salesconn.release();<br>}</PRE>
<p><A NAME="1037928"></A>
Вы можете также создать пул и изменить соединение на странице, доступной 
пользователю. В этом случае Вы должны быть осторожны, так как несколько 
пользователей, осуществляющих одновременный доступ к этой странице, не должны 
мешать друг другу. Например, только один пользователь должен иметь возможность 
создавать пул, используемый всеми остальными пользователями. О надёжности 
совместного использования информации см. раздел <A HREF="sessmgmt.htm#1012796">"Надёжное 
Совместное Использование Объектов с Помощью Блокировки&quot;</A>.</p>
<h4>
<A NAME="Head2;"></A><A NAME="1044823"></A>Совместное Использование Массива 
Пулов Соединений</h4>
<hr><p>
<A NAME="1073294"></A>
В разделе
<A HREF="#1043363">"Совместное Использование Фиксированного Набора Пулов 
Соединений"</A> описано, как Вы можете применить свойства объекта <CODE>project</CODE> 
для совместного использования фиксированного набора пулов соединений. Этот 
подход используется, если Вам в процессе разработки уже известно количество 
необходимых пулов соединений и Вам нужно только небольшое количество соединений.</p>
<p>
<A NAME="1044825"></A>
Часто нельзя предугадать заранее количество необходимых пулов соединений. В 
других случаях это возможно, но это количество недопустимо велико. Например, 
предположим, что для каждого потребителя, имеющего доступ к Вашему приложению, 
приложение проверяет пользовательский профиль на предмет определения того, какую 
информацию из БД вывести. Вы можете дать каждому потребителю уникальный 
пользовательский идентификатор ID для БД. Такое приложение требует, чтобы каждый 
пользователь имел свой набор параметров соединений (соответствующий различным 
пользовательским ID в БД) и, соответственно, разные пулы соединений.</p>
<p>
<A NAME="1065427"></A>
Вы можете создать объект <CODE>DbPool</CODE> и соединять и отсоединять его на 
каждой странице приложения. Это будет работать, только если одно соединение не 
должно захватывать несколько клиентских запросов. Иначе эта ситуация должна 
обрабатываться по-разному.</p>
<p>
<A NAME="1055592"></A>
Для данного приложения, вместо создания фиксированного набора пулов соединений 
на начальной странице приложения или пула на каждой клиентской странице, Вы 
создаёте одно свойство объекта <CODE>project</CODE>, которое будет содержать 
массив пулов соединений. Доступ к элементам этого массива осуществляется по 
ключу на базе определённого пользователя.<br>
Во время инициализации Вы создаёте массив, но не помещаете в него элементы (поскольку 
никто ещё не пытался использовать приложение), как показано здесь:</p>
<PRE><A NAME="1065459"></A>project.sharedPools = new Object();</PRE>
<p><A NAME="1044926"></A>
Когда пользователь впервые стартует приложение, оно получает идентифицирующий 
пользователя ключ. На основе этого ключа приложение создаёт объект пула <CODE>DbPool</CODE> 
и сохраняет его в массиве пулов. Имея данный пул соединений, оно может либо 
соединяться на каждой странице, либо устанавливать соединение так, как описано в 
разделе <A HREF="#1051155">"Обслуживание Соединения по Запросам."</A> Следующий 
код создаёт пул либо получает уже созданный, проверяет его соединение и работает 
затем с БД:</p>
<PRE><A NAME="1065492"></A>// Генерируется уникальный индекс для обращения к данному клиенту, если это<br>// ещё не было сделано на другой странице. О функции ssjs_generateClientID см.<br>// <A HREF="sessmgmt.htm#1046600">"Уникальное Обращение к Объекту client"</A>.

if client.id == null {<br>&nbsp;&nbsp;&nbsp;client.id = ssjs_generateClientID();<br>}</PRE>
<PRE><A NAME="1065496"></A>// Если пула для данного клиента ещё нет, он создаётся<br>// и производится его соединение с БД.

project.lock();<br>if (project.sharedPools[client.id] == null)
{<br>&nbsp;&nbsp;&nbsp;project.sharedPools[client.id] = new DbPool ("ORACLE",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"myserver", user, password, "", 5, false);<br>}<br>project.unlock();</PRE><PRE><A NAME="1065504"></A>// Для удобства устанавливается переменная для этого пула.
<br>var clientPool = project.sharedPools[client.id];</A></PRE><PRE><A NAME="1065508"></A>// Теперь у Вас есть пул: посмотрим, соединён ли он. Если нет, попытаемся соединить его.<br>// Если это не удаётся, перенаправляем на специальную страницу,<br>// чтобы проинформировать пользователя.
<br>project.lock();<br>if (!clientPool.connected()) {<br>&nbsp;&nbsp;&nbsp;clientPool.connect("ORACLE", "myserver", user, password, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"", 5, false);<br>&nbsp;&nbsp;&nbsp;if (!clientPool.connected()) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete project.sharedPools[client.id];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;project.unlock(); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;redirect("noconnection.htm");<br>&nbsp;&nbsp;&nbsp;}<br>}<br>project.unlock();</PRE><PRE><A NAME="1067938"></A>// Если Вы дошли до этого места, Вы успешно соединились и<br>// можете работать с БД.
<br>clientConn = clientPool.connection();<br>clientConn.SQLTable("select * from customers");
<br>// <I>... другие операции с БД ...</I></PRE><PRE><A NAME="1067939"></A>// Всегда освобождайте соединение, если оно Вам больше не нужно.
<br>clientConn.release();<br>}</PRE>
<p><A NAME="1044984"></A>
Когда пользователь в следующий раз войдёт в приложение (например, с другой 
страницы приложения), он использует тот же самый код и получит сохранённый пул 
соединений и (возможно, сохранённый,) объект <CODE>Connection</CODE> из объекта <CODE>project</CODE>.</p>
<p>
<A NAME="1067201"></A>
Если Вы используете <CODE>ssjs_generateClientID</CODE> и сохраняете ID в объекте <CODE>client</CODE>, 
Вам может понадобиться защита от вторжения через доступ к этому ID и, 
следовательно, к закрытой информации.</p>
</P>
<h6>ПРИМЕЧАНИЕ:</h6>
<p> <A NAME="1065805"></A>
Объект <CODE>sharedConns</CODE>, использованный в этом примере кода, не является 
предопределённым объектом 
JavaScript. Он просто создан в этом примере и может иметь другое имя по Вашему 
выбору.</p>
<H2>
<A NAME="Individual Database Connections"></A><A NAME="1044987"></A>
Индивидуальные Соединения с Базой Данных</H2><hr><p><A NAME="1030118"></A>
Как только Вы создали пул соединений, клиентская страница может получить доступ 
к индивидуальному соединению из пула. Если Вы используете объект <CODE>database</CODE>, 
соединение в данном объекте является неявным; то есть Вы используете методы 
объекта <CODE>database</CODE> для доступа к соединению. Если, однако, Вы 
используете объекты <CODE>DbPool</CODE>, соединение инкапсулируется в объекте <CODE>Connection</CODE>, 
который Вы получаете через вызов метода объекта <CODE>DbPool</CODE>. Например, в 
следующем пуле:</p>
<PRE><A NAME="1030126"></A>project.eng = new DbPool ("ORACLE", "myserver", "ENG", "pwd1", "", 5);</PRE>
<p><A NAME="1030127"></A>
Вы можете получить соединение из пула с помощью такого вызова метода:</p>
<PRE><A NAME="1030128"></A>myconn = project.eng.connection ("My Connection", 60);</PRE>
<p><A NAME="1030129"></A>
Оба параметра метода являются необязательными. Первый это имя соединения (используется 
при отладке); второй это целое число, обозначающее таймаут в секундах. В этом 
примере, если пул имеет доступное соединение или если оно становится доступным в 
течение 60 секунд, это соединение присваивается переменной <CODE>myconn</CODE>. 
Если соединение не становится доступным в течение указанного периода, этот метод 
возвращается без соединения. Дополнительно об ожидании получения соединения из 
пула см. раздел <A HREF="#1051335">"Ожидание Соединения&quot;</A>. О том, что делать, 
если соединение не получено, см. <A HREF="#1051342">"Запрашивание Незанятого 
Соединения&quot;</A>.</p>
<p>
<A NAME="1030131"></A>
Если Вы закончили использование соединения, возвратите его в пул путём вызова 
метода <CODE>release</CODE> объекта <CODE>Connection</CODE>. (Если Вы 
используете объект <CODE>database</CODE>, Вам не нужно самостоятельно 
освобождать соединение). Прежде чем вызвать метод <CODE>release</CODE>, закройте 
все открытые курсоры, хранимые процедуры и результирующие наборы. Если Вы 
вызываете метод <CODE>release</CODE>, система ожидает, когда всё закроется, и 
возвращает затем соединение в пул базы данных. После этого соединение доступно 
следующему пользователю. Об использовании курсоров см. <A HREF="db2.htm#1030418">"Манипуляции 
с Результатами Запросов с Помощью Курсоров&quot;</A>. О хранимых процедурах и 
результирующих наборах см. <A HREF="db2.htm#1030702">"Вызов Хранимых Процедур&quot;</A>.</p>
<p>
<A NAME="1030157"></A>
После получения соединения (через объект <CODE>database</CODE> или объект <CODE>Connection</CODE>), 
Вы можете работать с БД. В таблице резюмированы методы объектов <CODE>database</CODE> 
и <CODE>connection</CODE> для работы с единственным соединением. Объект <CODE>database</CODE> 
имеет и другие методы для обслуживания пула соединений, рассмотренные в разделе <A HREF="#1070974">"Обслуживание 
Пулов Соединений."</A></p>
<A NAME="1073110"></A><h5>
<A NAME="1048295"></A>
Таблица 8.4&nbsp; Методы Объектов</a>&nbsp;<CODE>database</CODE> и <CODE>Connection</CODE> 
для Работы с Единственным Соединением</h5>
<TABLE BORDER="2" CELLPADDING=5><TR><TH VALIGN=baseline ALIGN=left><A NAME="1038102"></A>
Метод<TH VALIGN=baseline ALIGN=left><A NAME="1038104"></A>Описание<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1038107"></A>
<CODE>cursor</CODE></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1038109"></A>
Создаёт курсор БД для специфицированного оператора SQL <CODE>SELECT</CODE>.</P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1038112"></A>
<CODE>SQLTable</CODE></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1038114"></A>
Отображает результаты выполнения запроса. Создаёт таблицу HTML для результата выполнения оператора SQL <CODE>SELECT</CODE>.</P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1038117"></A>
<CODE>execute</CODE></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1038119"></A>
Выполняет специфицированный оператор SQL. Используется для операторов SQL, отличных от запросов/queries.</P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1038122"></A>
<CODE>connected</CODE></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1038124"></A>
Возвращает <CODE>true</CODE>, если пул БД (и, следовательно, данное соединение) соединён с БД.</P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1038127"></A>
<CODE>release</CODE></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1038129"></A>
(Только для<CODE> Connection</CODE>) Освобождает соединение обратно в пул.</P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1038132"></A>
<CODE>beginTransaction</CODE></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1038134"></A>
Начинает транзакцию SQL.</P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1038137"></A>
<CODE>commitTransaction</CODE></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1038139"></A>
Подтверждает текущую транзакцию SQL.</P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1038142"></A>
<CODE>rollbackTransaction</CODE></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1038144"></A>
Выполняет откат текущей транзакции SQL.</P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1038147"></A>
<CODE>storedProc</CODE></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1038193"></A>
Создаёт объект хранимой процедуры и запускает специфицированную хранимую процедуру БД.</P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1038156"></A>
<CODE>majorErrorCode</CODE></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1038158"></A>
Важнейший код ошибки, возвращаемый сервером БД или ODBC.</P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1038161"></A>
<CODE>majorErrorMessage</CODE></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1038163"></A>
Сообщение о важнейшей ошибке, возвращаемое сервером БД или ODBC.</P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1038166"></A>
<CODE>minorErrorCode</CODE></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1038168"></A>
Второй по значению код ошибки, возвращаемый библиотекой производителя.</P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1038171"></A>
<CODE>minorErrorMessage</CODE></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1038173"></A>
Второе по значению сообщение о важнейшей ошибке, возвращаемое библиотекой производителя.</P></TABLE>
<h4><A NAME="Head2;"></A><A NAME="1051155"></A>Обслуживание Соединения по Нескольким Запросам</h4>
<hr><p><A NAME="1051156"></A>
В некоторых случаях может понадобиться, чтобы единственное соединение 
захватывало несколько клиентских запросов. То есть Вы сможете использовать одно 
соединение на нескольких страницах HTML.</p>
<p><A NAME="1051157"></A>Обычно вы используете свойства объекта <CODE>client</CODE> для информации, 
захватывающего клиентские запросы. Однако значение свойства объекта <CODE>client</CODE> 
не может быть объектом. Исходя из этого, Вы не можете сохранять пул соединений 
БД в объекте <CODE>client</CODE>. Вместо этого Вы используете пул соединений, 
хранимый в объекте <CODE>project</CODE>, обслуживая их так, как описано в данном 
разделе. Если вы используете этот подход, Вам может понадобиться кодирование 
пользовательской информации, по соображениям безопасности.</p>
<h6>ПРЕДУПРЕЖДЕНИЕ!</h6><p> <A NAME="1051159"></A>
Будьте особенно осторожны при использовании такого подхода, поскольку сохранение 
соединения таким способом делает его недоступным для других пользователей. Если 
все соединения окажутся недоступны, новые запросы будут ожидать явного 
освобождения соединения или таймаута соединения. Это особенно проблематично для 
однопоточных библиотек БД. (Об установлении соединений так, что они будут 
запрашиваться, если не заняты в течение продолжительного времени, см. <A HREF="#1051342">"Запрашивание 
Незанятого Соединения"</A>).</p>
<p>
<A NAME="1051163"></A>&nbsp;В следующем примере соединение и транзакция 
захватывают несколько клиентских запросов. Код сохраняет соединение как свойство 
объекта <CODE>sharedConns</CODE>, который сам является свойством объекта <CODE>project</CODE>. 
Объект <CODE>sharedConns </CODE>не является предопределённым объектом JavaScript. 
Он просто создан в данном примере и может иметь другое имя, по Вашему выбору.</p>
<p>
<A NAME="1065817"></A>
Поскольку один пул используется всеми клиентами, Вы должны создавать объект <CODE>sharedConns</CODE> 
и создавать и соединять сам пул на начальной странице приложения примерно таким 
кодом:</p>
<PRE><A NAME="1065825"></A>project.sharedConns = new Object();<br>project.sharedConns.conns = new Object();<br>project.sharedConns.pool = new DbPool ("SYBASE", "sybaseserver",<br>&nbsp;&nbsp;&nbsp;"user", "password", "sybdb", 10, false);</PRE>
<p><A NAME="1056003"></A>
Затем на первой клиентской странице, получающей доступ к пулу, следуйте такой 
стратегии:</p>
<PRE><A NAME="1065866"></A>// Генерируется уникальный индекс для обращения к данному клиенту, если он ещё<br>// не сгенерирован на другой странице.
<br>if client.id == null {<br>&nbsp;&nbsp;&nbsp;client.id = ssjs_generateClientID();<br>}</PRE><PRE><A NAME="1065871"></A>// Для удобства устанавливается переменная для данного пула. 
<br>var clientPool = project.sharedConns.pool;</PRE><PRE><A NAME="1065873"></A>// Проверяется, соединён ли пул. Если нет, перенаправляется<br>// на специальную страницу для информирования пользователя.
<br>project.lock();<br>if (!clientPool.connected()) {<br>&nbsp;&nbsp;&nbsp;delete project.sharedConns.pool;<br>&nbsp;&nbsp;&nbsp;project.unlock();<br>&nbsp;&nbsp;&nbsp;redirect("noconnection.htm");<br>}<br>project.unlock();</PRE><PRE><A NAME="1065886"></A>// Соединение получается из пула и сохраняется в объекте project.
<br>project.sharedConns.conns[client.id] = clientPool.connection();<br>var clientConn = project.sharedConns.conns[client.id];</A></PRE>
<PRE><A NAME="1065890"></A>clientConn.beginTransaction();<br>cursor = clientConn.cursor("select * from customers", true");
<br>// <I>... другие операции с БД ...
</I><br>cursor.close();</PRE>
<PRE><A NAME="1065893"></A>}</PRE>
<p><A NAME="1051177"></A>
Заметьте, что эта страница не выполняет откат или подтверждение транзакции. 
Соединение остаётся открытым, и транзакция продолжается. (Транзакции 
рассматриваются в разделе <A HREF="db2.htm#1040958">"Обслуживание Транзакций&quot;</A>).<br>
Вторая HTML-страница запрашивает соединение, базируясь на значении <CODE>client.id</CODE>, 
и продолжает работать с БД так:</p>
<PRE><A NAME="1065981"></A>// Запрашивается соединение.
<br>var clientConn = project.sharedConns.conns[client.id];</A></PRE>
<PRE><A NAME="1065995"></A>// <I>... Выполняются ещё какие-нибудь операции с БД ...<br></I>// Здесь, если операции с БД успешно прошли, okay устанавливается в 1.<br>
// Если была ошибка при работе с БД, okay устанавливается в 0. В конце<br>// подтверждается или откатывается транзакция на основе этого значения.<br>
if (okay) <br>
&nbsp;&nbsp;&nbsp;clientConn.commitTransaction();<br>else<br>&nbsp;&nbsp;&nbsp;clientConn.rollbackTransaction();</PRE>
<PRE><A NAME="1065991"></A>// Соединение возвращается в пул.<br>
clientConn.release();</PRE>
<PRE><A NAME="1066021"></A>// Избавляемся от значения свойства объекта. Оно Вам больше не нужно. <br>
delete project.sharedConns.conns[client.id];</PRE>
<p><A NAME="1066028"></A>
В этом примере объект <CODE>sharedConns</CODE> сохраняет единственный объект <CODE>DbPool</CODE> 
и соединения для данного пула, которые используются в данный момент. Ситуация 
может быть значительно сложнее. Если у Вас имеется фиксированный набор пулов БД, 
Вы можете  определить отдельный объект для хранения соединений каждого пула.<br>
Если у вас имеется массив пулов и каждому пулу необходимы соединения, 
захватывающие несколько запросов, Вам необходимо создать массив объектов, каждый 
из которых сохраняет пул и массив его соединений. Как ответвление, вместо 
немедленного перенаправления в том случае, если пул не соединён, клиентская 
страница может сделать новую попытку установить соединение.</p>
<p>
<A NAME="1067255"></A>
Если Вы используете <CODE>ssjs_generateClientID</CODE> и храните ID в объекте <CODE>client</CODE>, 
Вам понадобится защита от вторжения и получения доступа к ID и, следовательно, к 
закрытой информации.</p>
<h4>
<A NAME="Head2;"></A><A NAME="1051335"></A>Ожидание Соединения</h4><hr><p><A NAME="1051713"></A>
В пуле, созданном объектом <CODE>DbPool</CODE>, соединений имеется фиксированное 
количество соединений. Если в момент попытки доступа все соединения заняты, Ваше 
приложение ожидает освобождения соединения в течение специфицированного периода 
таймаута. Вы можете управлять периодом ожидания.</p>
<p>
<A NAME="1051336"></A>
Предположим, Вы определили следующий пул из 3 соединений:</p>
<PRE><A NAME="1051337"></A>pool = new DbPool ("ORACLE", "myserv", "user", "password", "", 3);</PRE>
<p><A NAME="1051338"></A>
Предположим далее, что три клиента одновременно получают доступ к приложению и 
каждый использует одно из трёх соединений. Четвёртый клиент теперь запрашивает 
соединение через следующий вызов:</p>
<PRE><A NAME="1051339"></A>myconnection = pool.connection();</PRE>
<p><A NAME="1051340"></A>
Этот клиент обязан ждать, пока один из трёх клиентов не освободит соединение. В 
данном случае, поскольку вызов <CODE>connection</CODE> не специфицирует таймаут, 
клиент ждёт освобождения соединения неопределённо долго, а затем возвращает это 
соединение.</p>
<p>
<A NAME="1051992"></A>
Вы можете специфицировать различные периоды таймаута, задавая аргументы метода <CODE>connection</CODE>. 
Второй аргумент метода <CODE>connection</CODE> это период таймаута в секундах. 
Если Вы специфицируете таймаут 0, система ждёт бесконечно долго. Например, 
следующий код ожидает соединения только 30 секунд перед таймаутом:</p>
<PRE><A NAME="1051341"></A>myconnection = pool.connection ("Name of Connection", 30);</PRE>
<p><A NAME="1052003"></A>
Если в течение специфицированного периода соединение не освобождается, метод 
возвращает null, и в сообщение об ошибке устанавливается сообщение о наименьшей 
ошибке. Вы можете получить это сообщение, вызвав метод <CODE>minorErrorMessage</CODE> 
объекта <CODE>pool</CODE>. Если Вы вызываете таймаут из <CODE>connection</CODE>, 
Вам может понадобиться освободить соединение, отключив одно из уже установленных. 
Дополнительно см. <A HREF="#1051342">"Запрашивание Свободного Соединения&quot;</A>.</p>
<h4>
<A NAME="Head2;"></A><A NAME="1051342"></A>Запрашивание Свободного Соединения</h4>
<hr><p><A NAME="1070182"></A>
Если Ваше приложение запрашивает соединение из объекта <CODE>DbPool</CODE>, оно 
может не получить его. Доступные опции в этот момент зависят от архитектуры 
Вашего приложения.</p>
<p>
<A NAME="1070183"></A>
Если каждое соединение существует только в период существования отдельного 
клиентского запроса, недоступность соединений невозможна из-за того, что 
пользователь оставил приложение в бездействии на значительный период времени. 
Это может произойти только из-за того, что весь код страницы JavaScript не 
закончил выполняться. В этом случае Вы не должны пытаться разорвать используемое 
соединение, чтобы воспользоваться им. Если Вы разорвёте соединение в этот момент, 
Вы рискуете оставить этот поток выполнения в несоответствующем состоянии. Вместо 
этого Вы должны удостовериться, что Ваше приложение освобождает каждое 
соединение по мере завершения его использования. Если Вы не хотите ожидать 
соединения, Вы должны предоставить пользователю возможность выбора другого 
варианта.</p>
<p>
<A NAME="1052050"></A>
Если, наоборот, соединение захватывает несколько клиентских запросов, Вы можете 
захотеть запросить свободные соединения. В этой ситуации соединение может 
освободиться, поскольку пользователь не завершил транзакцию. Например, 
предположим, что пользователь отправляет данные на первой странице приложения и 
эти данные начинают многостраничную транзакцию БД. Вместо отправки данных для 
продолжения транзакции на следующей странице, пользователь переходит на другой 
сайт и никогда не вернётся к данному приложению. По умолчанию соединение 
остаётся открытым и не может использоваться другими клиентами.</p>
<p>
<A NAME="1052582"></A>
Вы можете вручную запросить соединение, зачистив его и освободив в пул БД. Чтобы 
сделать это, напишите функции типа нижеследующих:</p>
<ul><LI><A NAME="1051346"></A>
<CODE>Bucket</CODE>: Определяет тип объекта (в данном примере - с названием <CODE>bucket</CODE>) 
для содержания соединения и штампа времени.</LI><LI><A NAME="1051347"></A>
<CODE>MarkBucket</CODE>: Помечает объект <CODE>bucket</CODE> штампом текущего 
времени.</LI><LI><A NAME="1052892"></A>
<CODE>RetrieveConnections</CODE>: Проходит по массиву соединений в поисках 
объекта <CODE>Connection</CODE>, к которому не было доступа в течение 
установленного лимита времени, и использует <CODE>CleanBucket</CODE> (описан 
далее) для запрашивания этого объекта.</LI><LI><A NAME="1053810"></A>
<CODE>CleanBucket</CODE>: Закрывает курсоры (и возможные хранимые процедуры и 
результирующие наборы), откатывает или подтверждает каждую открытую транзакцию 
и возвращает соединение в пул.</LI></ul><p><A NAME="1051353"></A>
Ваше приложение может использовать эти функции так:</p>
<OL><LI><A NAME="1052711"></A>
Когда Вы получаете новое соединений, вызывайте <CODE>Bucket</CODE> для 
создания объекта <CODE>bucket</CODE>.</LI><LI><A NAME="1052748"></A>
На любой странице, получающей доступ к соединению, вызывайте <CODE>MarkBucket</CODE> 
для обновления штампа времени.</LI><LI><A NAME="1052815"></A>
Если приложение делает паузу (таймаут), пытаясь получить соединение их пула, 
вызывайте <CODE>RetrieveConnection</CODE> для поиска незанятых соединений, 
закройте все открытые курсоры, подтвердите или откатите работающие транзакции 
и верните незанятые соединения обратно в пул.</LI><LI><A NAME="1052816"></A>
Если соединение было возвращено в пул, попытайтесь получить соединение из пула.</LI></OL>
<p>
<A NAME="1055788"></A>
Также на каждой странице, где Ваше приложение использует соединение, необходимо 
убедиться, что другой поток освободил соединение, до того как данная страница 
будет достигнута данным клиентом.</p>
<h6>
<A NAME="HeadRunIn;"></A><A NAME="1051354"></A>
Создание Bucket</h6>
<p><A NAME="1053126"></A>Функция bucket содержит соединение и штамп времени. 
Этот образец конструктора функции принимает соединение в качестве единственного 
параметра:</p>
<PRE><A NAME="1053127"></A>// Конструктор для Bucket
<br>function Bucket(c)<br>{<br>&nbsp;&nbsp;&nbsp;this.connection = c;<br>&nbsp;&nbsp;&nbsp;this.lastModified = new Date();<br>}</PRE>
<p><A NAME="1051357"></A>
Вы можете вызвать эту функцию для создания bucket для соединения, когда Вы 
получаете соединение из пула соединений. Вы можете добавить другие свойства для 
соединения bucket. Например, Ваше приложение может содержать курсор, который 
захватывает клиентские запросы. Тогда Вы можете использовать свойство для 
добавления курсора в bucket, так чтобы можно было закрыть открытый курсор при 
запрашивании соединения. Вы сохраняете курсор в bucket во время его создания, 
как видно из следующего оператора:</p>
<PRE><A NAME="1051358"></A>myBucket.openCursor = <br>&nbsp;&nbsp;&nbsp;myBucket.connection.cursor("select * from customer", true);</PRE><h6><A NAME="HeadRunIn;"></A>
<A NAME="1051359"></A>Пометка Объекта Bucket</h6>
<p><A NAME="1051360"></A>Функция <CODE>MarkBucket</CODE> принимает объект <CODE>Bucket</CODE> 
в качестве параметра и устанавливает в поле <CODE>lastModified</CODE> текущее 
время.</p>
</P>
<PRE><A NAME="1051361"></A>function MarkBucket(bucket)<br>{<br>&nbsp;&nbsp;&nbsp;bucket.lastModified = new Date();<br>}</PRE>
<p><A NAME="1053186"></A>
Вызывайте <CODE>MarkBucket</CODE> на каждой странице приложения, которая 
использует соединение, содержащееся в bucket. Это восстанавливает в <CODE>lastModified</CODE> 
значение текущей даты и предотвращает появление незанятых соединений.</p>
<h6>
<A NAME="HeadRunIn;"></A><A NAME="1053338"></A>Запрашивание Старых Соединений</h6>
<p><A NAME="1053339"></A>
<CODE>RetrieveConnections</CODE> сканирует массив объектов <CODE>Bucket</CODE>, 
ищет buckets соединения, штамп времени которых установлен ранее некоторого 
определённого времени. Если соединение найдено, функция вызывает <CODE>CleanBucket</CODE> (описан 
далее) для возвращения соединения в пул БД.</p>
<PRE><A NAME="1066079"></A>// Запрашиваются соединения, не занятые в течение специфицированного количества минут.
<br>function RetrieveConnections(BucketArray, timeout)<br>{<br>&nbsp;&nbsp;&nbsp;var i;<br>&nbsp;&nbsp;&nbsp;var count = 0;<br>&nbsp;&nbsp;&nbsp;var now;</PRE>
<PRE><A NAME="1066080"></A>&nbsp;&nbsp;&nbsp;now = new Date();</PRE><PRE><A NAME="1066081"></A>
&nbsp;&nbsp;&nbsp;// Этот цикл выполняется для каждого bucket в массиве.<br>
&nbsp;&nbsp;&nbsp;for (i in BucketArray) {</PRE><PRE><A NAME="1053824"></A>
&nbsp;// Вычисляется разница во времени между текущей/now и последней/last<br>&nbsp;// модифицированной датой. Эта разница выражается в миллисекундах.<br> // Если она больше значения timeout, вызывается функция зачистки.</PRE><PRE><A NAME="1051371"></A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if ((now - i.lastModified)/60000) &gt; timeout) {<br>
CleanBucket(i);</PRE><PRE><A NAME="1053839"></A>// Избавляется от bucket, поскольку он больше не используется.<br>
&nbsp;&nbsp;delete i;</PRE><PRE><A NAME="1053856"></A>count = count + 1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;}
&nbsp;return count;<br>}</PRE>
<h6><A NAME="HeadRunIn;"></A>
<A NAME="1053766"></A>Зачистка Bucket</h6>
<p><A NAME="1053767"></A>После того как определено, что соединение должно быть 
запрошено (с помощью функции <CODE>RetrieveConnections</CODE>), Вам понадобится 
функция для зачистки подробностей соединения и возврата его обратно в пул базы 
данных.<br>
Данная функция-образец закрывает открытые курсоры, откатывает открытые 
транзакции и освобождает соединение.</p>
<PRE><A NAME="1053768"></A>function CleanBucket(bucket)<br>{<br>&nbsp;&nbsp;&nbsp;bucket.openCursor.close();<br>&nbsp;&nbsp;&nbsp;bucket.connection.rollbackTransaction();<br>&nbsp;&nbsp;&nbsp;bucket.connection.release();<br>}</PRE>
<p><A NAME="1053769"></A>
<CODE>CleanBucket</CODE> принимает, что данный bucket содержит открытый курсор 
и его соединение имеет открытую транзакцию. Принимается также, что отсутствуют 
хранимые процедуры и результирующие наборы. В Вашем приложении может 
понадобиться и какая-нибудь другая проверка.</p>
<h6>
<A NAME="HeadRunIn;"></A><A NAME="1051373"></A>Направление Их Всех в Пул</h6>
<p><A NAME="1053861"></A>Следующий пример кода использует уже определённые 
функции для запрашивания соединений, к которым не обращались в течение 10 минут. 
Сначала создаётся совместно используемый массив соединений и пул БД с 5 
соединениями:</p>
<PRE><A NAME="1051375"></A>if ( project.sharedConns == null ) {<br>&nbsp;&nbsp;&nbsp;project.sharedConns = new Object();<br>&nbsp;&nbsp;&nbsp;project.sharedConns.pool = new DbPool ("ORACLE", "mydb",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"user", "password", "", 5, false);<br>&nbsp;&nbsp;&nbsp;if ( project.sharedConns.pool.connected() ) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;project.sharedConns.connections = new Object();<br>&nbsp;&nbsp;&nbsp;}</PRE><PRE><A NAME="1071726"></A>else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete project.sharedConns;<br>&nbsp;&nbsp;&nbsp;}<br>}</PRE>
<p>
<A NAME="1051380"></A>
Теперь используем следующий код для попытки получения соединения. После зачистки 
пула генерируется клиентский ID, который затем используется как индекс в массиве 
соединений. Далее пытаемся получить соединение. Если возникает таймаут, вызываем <CODE>RetrieveConnections</CODE> 
для возвращения старого соединения в пул.<br>
Если <CODE>RetrieveConnections</CODE> возвращает соединение в пул, пытаемся 
получить соединение вновь. Если всё ещё не можем получить соединение, 
выполняется перенаправление на другую страницу с информацией, что свободных 
соединений нет. Если запрашивается соединение, сохраняем его в новом bucket 
соединения и сохраняем этот bucket соединения в совместно используемом массиве 
соединений.</p>
</P>
<PRE><A NAME="1051384"></A>if ( project.sharedConns != null ) {<br>&nbsp;&nbsp;&nbsp;var pool = project.sharedConns.pool;</PRE><PRE><A NAME="1051385"></A>&nbsp;&nbsp;&nbsp;// Этот код запускается, только если пул уже соединён.<br>&nbsp;&nbsp;&nbsp;// Если нет, возможно, Вам нужен код для соединения.
<br>&nbsp;&nbsp;&nbsp;if ( pool.connected() == true ) {</PRE>
<PRE><A NAME="1053965"></A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Генерируется клиентский ID. <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;client.id = ssjs_generateClientID();</PRE>
<PRE><A NAME="1053968"></A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Попытка получить соединение.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var connection = pool.connection("my connection", 30);</PRE>
<PRE><A NAME="1051387"></A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Если соединение null, тогда ничего не будет доступно
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// в течение специфицированного лимита времени. Пытаемся запросить старые соединения.
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (connection == null) {</PRE>
<PRE><A NAME="1054044"></A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Запрашиваются соединения, не используемые в течение последних 10 минут.<br>
var count = RetrieveConnections(project.sharedConns.connections, 10);</PRE>
<PRE><A NAME="1054046"></A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Если count не равен 0, делаем какое-нибудь соединение доступным.<br>
if (count != 0){<br>
connection = pool.connection("my connection", 30);<br>
&nbsp;&nbsp;&nbsp;&nbsp;// Если connection всё ещё null, отказываемся.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (connection == null)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;redirect("nofreeconnections.htm");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Отказываемся.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;redirect("nofreeconnections.htm");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}}</PRE>
<PRE><A NAME="1051388"></A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Если Вы не дошли досюда, Вы получили соединение и можете продолжить работу.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Поместите это connection в новый bucket, стартуйте транзакцию,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// получайте курсор, сохраняйте его в bucket и продолжайте работу.
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;project.sharedConns.connections[client.id] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Bucket(connection);<br>
&nbsp;connection.beginTransaction();<br>
project.sharedConns.connections[client.id].cursor =<br>
connection.cursor("select * from customer", true);</PRE><PRE><A NAME="1066136"></A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Помечаем bucket соединения как использованный.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MarkBucket(project.sharedConns.connections[client.id]);</PRE>
<PRE><A NAME="1066137"></A>&nbsp;&nbsp;&nbsp;// Операторы Базы Данных.<br>&nbsp;&nbsp;&nbsp;...<br>}</PRE>
<p><A NAME="1051390"></A>
На следующей странице многостраничной транзакции выполняются операции БД по 
этому соединению. После последней операции БД по соединению помечается bucket 
соединения:</p>
<PRE><A NAME="1051391"></A>var Bucket = project.sharedConns.connections[client.id];</PRE><PRE><A NAME="1051392"></A>
if ( Bucket == null) {
<br>&nbsp;&nbsp;&nbsp;// Повторное соединение.<br>}</PRE><PRE><A NAME="1055975"></A>else {</PRE>
<PRE><A NAME="1055974"></A>&nbsp;&nbsp;&nbsp;// Взаимодействие с БД.<br>
...</PRE><PRE><A NAME="1055967"></A>&nbsp;&nbsp;&nbsp;// Последняя операция БД на странице.<br>
&nbsp;&nbsp;&nbsp;row = Bucket.cursor.next();<br>&nbsp;&nbsp;&nbsp;row.customerid = 666;<br>
&nbsp;Bucket.openCursor.insertRow("customer");</PRE><PRE><A NAME="1051394"></A>&nbsp;&nbsp;&nbsp;// Помечается bucket соединения как использованный на данной странице.
<br>&nbsp;&nbsp;&nbsp;MarkBucket(Bucket);<br>}</PRE>
<h5><font size="-1"><a href="contents.htm">Оглавление</a></font><FONT SIZE=-1> |
<a href="partlw.htm">Назад</a>
| <a href="db2.htm">Вперёд</a>
| <a href="bklast.htm">Индекс</a></FONT></h5>
<HR><P ALIGN=right><FONT SIZE=-2><I>Дата последнего обновления: 29 сентября 1999 г.</I></FONT><P><FONT FACE="PrimaSans BT, Verdana, Sans-Serif" SIZE=-2>
&copy; Copyright © 1999 Sun Microsystems, Inc. Некоторая часть Copyright 
© 1999 Netscape Communications Corp. Все Права Зарезервированы.</FONT>
</BODY></HTML>