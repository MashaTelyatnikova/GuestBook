<!doctype HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Language" content="ru">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<link rel="stylesheet" href="css.css" type="text/css">
<TITLE>Другая Функциональность JavaScript.</TITLE></HEAD>
<BODY>
<h5><a href="contents.htm">Оглавление</a> | <a href="sessmgmt.htm">Назад</a>
| <a href="partlw.htm">Вперёд</a>
| <a href="bklast.htm">Индекс</a><BR></h5><HR><A NAME="1017718"></a>
<h1>Глава 7<BR><A NAME="1020059"></a>Другая Функциональность JavaScript</h1>
<p><A NAME="1026546"></a>В этой главе рассматривается дополнительная 
функциональность серверного JavaScript, которую Вы можете использовать для 
отправки e-mail из Вашего приложения, для доступа к файловой системе сервера, 
подключения внешних библиотек или непосредственного манипулирования клиентскими запросами и клиентскими ответами.</p>
<p><A NAME="1033221"></a>В главе имеются следующие разделы:</p>
<ul><LI><A NAME="1032292"></a>
<A HREF="#1022979">Почтовая Служба</A><LI><A NAME="1032296"></a><A HREF="#1017481">
Служба Файловой Системы</A><LI><A NAME="1032300"></a><A HREF="#1026725">Работа 
с Внешними Библиотеками</A><LI><A NAME="1032304"></a><A HREF="#1020125">
Манипуляции с Запросами и Ответами</A></LI></ul>
<H2><A NAME="Mail Service"></A><A NAME="1022979"></a>Почтовая Служба/Mail Service</H2><hr><p><A NAME="1023076"></a>
Вашему приложению может понадобиться отправить email-сообщение. Для этого Вы 
используете экземпляры класса <CODE>SendMail</CODE>. Единственным методом <CODE>SendMail</CODE> 
является <CODE>send</CODE>, для отправки сообщения,
а <CODE>errorCode</CODE> и <CODE>errorMessage</CODE> служат для интерпретации ошибок.</p>
<p><A NAME="1023059"></a>Например, следующий скрипт отсылает почту в vpg со 
специфицированной темой/subject и телом сообщения:</p>
<PRE><A NAME="1019470"></a>&lt;server&gt;<br>SMName = new SendMail();<br>SMName.To = "vpg@royalairways.com";<br>
SMName.From = "thisapp@netscape.com";<br>SMName.Subject = "Here's the information you wanted";<br>
SMName.Body = "sharm, maldives, phuket, coral sea, taveuni, maui, <br>
&nbsp;&nbsp;&nbsp;cocos island, marathon cay, san salvador";<br>SMName.send();<br>&lt;/server&gt;</PRE>
<p><A NAME="1025653"></a>В таблице даны свойства класса <CODE>SendMail</CODE>.
Свойства <CODE>To</CODE> и <CODE>From</CODE> необходимы; все остальные свойства - по выбору/optional.</p>
<A NAME="1032615"></a><h5><A NAME="1025660"></a>Таблица 7.1&nbsp; Свойства класса <CODE>SendMail</CODE></h5>
<TABLE BORDER="2" CELLPADDING=5><TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1025664"></a>
<CODE>To</CODE></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1025666"></a>
Список разделённых запятыми первичных/primary получателей сообщения.</P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1025668"></a>
<CODE>From</CODE></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1025670"></a>
Имя пользователя/user name отправляющего сообщение.</P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1025672"></a>
<CODE>Cc</CODE></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1025674"></a>
Список разделённых запятыми дополнительных получателей сообщения.</P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1025676"></a>
<CODE>Bcc</CODE></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1025678"></a>
Список разделённых запятыми получателей сообщения, чьи имена не должны быть видны в сообщении.</P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1025680"></a>
<CODE>Smtpserver</CODE></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1025682"></a>
Имя почтового сервера (SMTP). По умолчанию это свойство имеет значение, 
установленное на сервере администрирования.</P><TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1025684"></a>
<CODE>Subject</CODE></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1025686"></a>
Тема сообщения.</P><TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1025688"></a>
<CODE>Body</CODE></P><TD VALIGN=baseline ALIGN=left><P><A NAME="1025690"></a>Текст сообщения.</P></TABLE>
<p><A NAME="1025832"></a>Вы можете добавлять к этим свойствам любые другие.
Все свойства класса <CODE>SendMail</CODE> включаются в шапку/header сообщения 
при фактической отправке. Например, следующий код отсылает сообщение получателю <CODE>bill</CODE> 
от <CODE>vpg</CODE>, устанавливая в поле <CODE>vpg</CODE> organization значение Royal Airways. 
Отвечает на сообщение от <CODE>vpgboss</CODE>.</p>
<PRE><A NAME="1025755"></a>mailObj["Reply-to"] = "vpgboss";<br>mailObj.Organization = "Royal Airways";<br>
mailObj.From = "vpg";<br>mailObj.To = "bill";<br>mailObj.send();</PRE>
<p><A NAME="1023472"></a>
Дополнительно о предопределённых полях шапки см.
<A HREF="http://info.internet.isi.edu:80/in-notes/rfc/files/rfc822.txt" TARGET="_blank">RFC 822</A>,
стандарт формата текстовых сообщений Internet.</p>
<p><A NAME="1025917"></a>
Класс <CODE>SendMail</CODE> позволяет отправлять простое текстовое почтовое 
сообщение или сложное MIME-сообщение. Вы можете также добавить в сообщению 
приложение/attachment. Для отправки MIME-сообщения добавьте свойство <CODE>Content-type</CODE> 
к объекту <CODE>SendMail</CODE> и укажите в нём MIME-тип сообщения.</p>
<p><A NAME="1029740"></a>
Например, следующий участок кода отсылает изображение в формате GIF:</p>
<PRE><A NAME="1029741"></a>&lt;server&gt;<br>SMName = new SendMail();<br>SMName.To = "vpg@royalairways.com";<br>
SMName.From = "thisapp@netscape.com";<br>SMName.Subject = "Here's the image file you wanted";<br>
SMName["Content-type"] = "image/gif"; <br>SMName["Content-Transfer-Encoding"] = "base64"; </PRE>
<PRE><A NAME="1030236"></a>// В следующем операторе image2.gif обязан быть кодирован с базой 64/base 64.<br>
// Если вы используете uuencode для кодирования GIF-файла, удалите header<br>// (например, "begin 644 image2.gif")
и замыкающий ("end").
<br>fileObj = new File("/usr/somebody/image2.gif"); </PRE>
<PRE><A NAME="1030257"></a>openFlag = fileObj.open("r"); <br>if ( openFlag ) { <br>
&nbsp;&nbsp;&nbsp;len = fileObj.getLength(); <br>&nbsp;&nbsp;&nbsp;SMName.Body = fileObj.read(len); <br>
&nbsp;&nbsp;&nbsp;SMName.send(); <br>&nbsp;&nbsp;&nbsp;}<br>&lt;/server&gt;</PRE>
<p><A NAME="1029761"></a>
Некоторые MIME-типы требуют больше информации. Например, если content type это <CODE>multipart/mixed</CODE>,
Вы обязаны также специфицировать сепаратор границ для одного или более различных 
наборов данных тела. Например, следующий код отсылает многочастное сообщение, 
содержащее две части, каждая из которых является обычным текстом:</p>
<PRE><A NAME="1029765"></a>&lt;server&gt;<br>SMName = new SendMail();<br>SMName.To = "vpg@royalairways.com";<br>
SMName.From = "thisapp@netscape.com";<br>SMName.Subject = "Here's the information you wanted";<br>
SMName["Content-type"] <br>&nbsp;&nbsp;&nbsp;= "multipart/mixed; boundary=\"simple boundary\""; <br>
fileObj = new File("/usr/vpg/multi.txt"); <br>openFlag = fileObj.open("r"); <br>if ( openFlag ) { <br>
&nbsp;&nbsp;&nbsp;len = fileObj.getLength(); <br>&nbsp;&nbsp;&nbsp;SMName.Body = fileObj.read(len); <br>
&nbsp;&nbsp;&nbsp;SMName.send(); <br>&nbsp;&nbsp;&nbsp;}<br>&lt;/server&gt;</PRE>
<p><A NAME="1029780"></a>
Вот файл <CODE>multi.txt</CODE>, содержащий многочастное сообщение:</p>
<PRE><A NAME="1030560"></a>Это место для преамбулы. <br>Она игнорируется.<br>Это удобное место для комментария,
предназначенного для читателей, не знакомых с MIME.
<br>--простая граница</PRE>
<PRE><A NAME="1029784"></a>Это первая часть тела сообщения. <br>Это НЕ конец с символом обрыва строки.</PRE>
<PRE><A NAME="1030617"></a>--простая граница
<br>Content-Type: text/plain; charset=us-ascii </PRE>
<PRE><A NAME="1029788"></a>Это вторая часть  тела сообщения.<br>Это КОНЕЦ с символом обрыва строки.</PRE>
<PRE><A NAME="1029790"></a>--простая граница--
<br>Это эпилог. Он также игнорируется.</PRE><p>
<A NAME="1029793"></a>Вы можете вкладывать друг в друга многочастные сообщения. 
То есть, если у Вас есть сообщение, content
type которого многочастный, Вы можете включить другой многочастное сообщение в 
его тело. В таких случаях будьте внимательны и убедитесь, штаа каждый вложенный 
многочастный объект использует разные ограничители.</p>
<p><A NAME="1029738"></a>Детали о MIME-типах см. в
<A HREF="http://info.internet.isi.edu:80/in-notes/rfc/files/rfc1341.txt" TARGET="_blank">RFC 1341</A>
<A HREF="#1029528"><SUP><font color="#FF0000">1</font></SUP></A>, MIME-стандарте. Об отправке почтовых 
сообщений в JavaScript см. также описание этого класса в книге <I>
<a href="../servref12/default.htm">Серверный
JavaScript. Справочник</a></I>.</p>
<H2><A NAME="File System Service"></A>
<A NAME="1017481"></a>Служба Файловой Системы</H2><hr>
<p><A NAME="1017472"></a>
JavaScript предоставляет класс <CODE>File</CODE>, который даёт приложению 
возможность записывать в файловой системе сервера. Это используется для 
генерации постоянных HTML-файлов и хранения информации без использования сервера 
БД. Одним из важнейших преимуществ хранения информации в файле вместо JavaScript-объектов 
является то, что информация сохраняется даже при отказе сервера.</p>
<h4><A NAME="Head2;"></A><A NAME="1026215"></A>Проблемы Безопасности</h4><hr>
<p><A NAME="1015416"></a>
Соблюдайте осторожность при использовании класса <CODE>File</CODE>. Приложение JavaScript 
может читать или записывать файлы везде, где позволяет операционная система, в 
том числе, возможно, и в системных файлах. Вы должны быть уверены, что Ваше 
приложение не позволяет читать файлы паролей и другую закрытую информацию или 
записывать в файлы. Делайте так, чтобы имена файлов, которые Вы передаёте в 
методы, не могли быть изменены хакерами.</p>
<p><A NAME="1026222"></a>Например, не используйте свойства объектов <CODE>client</CODE> 
или
<CODE>request</CODE> в качестве имён файлов, поскольку эти значения могут стать 
доступными хакеру через куки или URL. В таких случаях хакер сможет 
модифицировать куки или URL, чтобы получить доступ к закрытым файлам.</p>
<p><A NAME="1015420"></a>Исходя из таких же соображений, Navigator не 
предоставляет автоматического доступа к файловой системе клиентской машины. Если 
необходимо, пользователь может сохранять информацию непосредственно в клиентской 
файловой системе, делая соответствующий выбор в меню Navigator'а.</p>
<h4><A NAME="Head2;"></A><A NAME="1015421"></a>Создание File-Объекта</h4><hr>
<p><A NAME="999840"></a>
Чтобы создать экземпляр класса <CODE>File</CODE>, используйте стандартный 
синтаксис JavaScript для создания объекта:</p>
<PRE><A NAME="999841"></a>fileObjectName = new File("path");</PRE>
<p><A NAME="999842"></a>
Здесь <CODE>fileObjectName</CODE> это имя, по которому Вы обращаетесь к файлу, а <CODE>path</CODE> 
это полный путь к файлу. Этот path должен быть в формате серверной файловой 
системы, а не URL.</p>
<p><A NAME="1010647"></a>Вы можете отобразить имя файла, используя функцию <CODE>write</CODE> 
с <CODE>File</CODE> -объектом в качестве аргумента. Например, следующий оператор выводит имя файла:</p>
<PRE><A NAME="1010648"></a>x = new File("\path\file.txt");<br>write(x);</PRE>
<h4><A NAME="Head2;"></A><A NAME="1000399"></a>Открытие и Закрытие Файла</h4><hr><p>
<A NAME="999843"></a>После создания <CODE>File</CODE> -объекта Вы можете 
использовать метод <CODE>open</CODE> для открытия файла и чтения и записи. Метод <CODE>open</CODE> 
имеет следующий синтаксис:</p>
<PRE><A NAME="999913"></a>result = fileObjectName.open("mode");</PRE><p><A NAME="999914"></a>
Это метод возвращает <CODE>true</CODE>, если операция прошла успешно, и <CODE>false</CODE> в ином случае.
Если файл уже открыт, операция терпит неудачу, и оригинальный файл остаётся открытым.</p>
<p><A NAME="1023959"></a>Параметр <CODE>mode </CODE>это строка, специфицирующая режим открытия файла. В 
таблице описаны эти режимы.</p><A NAME="1033204"></a><h5><A NAME="1023970"></a>
Таблица 7.2&nbsp; Режимы доступа к файлу</h5><TABLE BORDER="2" CELLPADDING=5>
<TR><TH VALIGN=baseline ALIGN=left><A NAME="1023974"></a>Режим<TH VALIGN=baseline ALIGN=left>
<A NAME="1023976"></a>Описание<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1023978"></a>
r</P><TD VALIGN=baseline ALIGN=left><P><A NAME="1023980"></a>
Открывает файл, если он существует, как текстовый файл для чтения и возвращает <CODE>true</CODE>. 
Если файл не существует, возвращает <CODE>false</CODE>.</P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1023982"></a>
w</P><TD VALIGN=baseline ALIGN=left><P><A NAME="1023984"></a>
Открывает файл как текстовый файл для записи. Создаёт новый (первоначально 
пустой) текстовый файл, независимо от того, существует файл или нет.</P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1023986"></a>
a</P><TD VALIGN=baseline ALIGN=left><P><A NAME="1023988"></a>
Открывает файл как текстовый файл для дополнения (записи в конец файла). Если файл ещё не существует, создаёт его.</P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1023990"></a>
r+</P><TD VALIGN=baseline ALIGN=left><P><A NAME="1023992"></a>Открывает файл как 
текстовый файл для чтения и записи. Чтение и запись начинаются в начале файла. 
Если файл существует, возвращает <CODE>true</CODE>. Если не существует, возвращает <CODE>false</CODE>.</P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1023994"></a>
w+</P><TD VALIGN=baseline ALIGN=left><P><A NAME="1023996"></a>
Открывает файл как текстовый файл для чтения и записи. Создаёт новый (первоначально 
пустой) текстовый файл, независимо от того, существует файл или нет.</P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1023998"></a>
a+</P><TD VALIGN=baseline ALIGN=left><P><A NAME="1024000"></a>Открывает файл как 
текстовый файл для чтения и записи. Чтение и запись начинаются в конце файла. Если файл не существует, создаёт его.</P>
<TR><TD VALIGN=baseline ALIGN=left><P><A NAME="1024002"></a>
b</P><TD VALIGN=baseline ALIGN=left><P><A NAME="1024004"></a>Если присоединён к одному из вышеуказанных режимов,
открывает файл как бинарный/двоичный файл, а не как текстовый. Применяется только для операционных систем Windows.</P></TABLE>
<p><A NAME="1024005"></a>Когда приложение заканчивает использование файла, оно 
может закрыть его, вызвав метод <CODE>close</CODE>. Если файл не открыт, <CODE>close</CODE> 
терпит неудачу. Это метод возвращает <CODE>true</CODE> при успехе и <CODE>false</CODE> - в противном случае.</p>
<h4><A NAME="Head2;"></A><A NAME="1000750"></a>Блокировка Файлов</h4><hr><p><A NAME="1003931"></a>
Часто доступ ко многим приложениям могут выполнять одновременно многие 
пользователи. Вообще разные пользователи не должны пытаться одновременно вносить 
изменения в файлы, поскольку это может привести к непредсказуемым ошибкам.</p>
<p><A NAME="1003967"></a>Чтобы предотвратить модификацию файла одновременно 
несколькими пользователями, используйте один из механизмов блокирования, 
предоставляемых службой Session Management Service, как описано в разделе
<A HREF="sessmgmt.htm#1012796">"Безопасное Совместное Использование Объектов с 
Помощью Блокировки&quot;</A>. Если один пользователь блокировал файл,
другие пользователи приложения должны ждать, пока файл не будет разблокирован. В 
общем это означает, что <CODE>lock </CODE>(замок/блокировка) должна предшествовать всем 
файловым операциям; после выполнения операций должно выполняться <CODE>unlock </CODE>(разблокирование).</p>
<p><A NAME="1017866"></a>Если только одно приложение может модифицировать данный 
файл, Вы можете получать блокировку в объекте <CODE>project</CODE>. Если более 
чем одно приложение может иметь доступ к одному и тому же файлу, получайте 
блокировку в объекте <CODE>server</CODE>.</p><p><A NAME="1010612"></a>
Например, у Вас создан файл <CODE>myFile</CODE>. Затем Вы может использовать его так:</p>
<PRE><A NAME="1010613"></a>if ( project.lock() ) {<br>&nbsp;&nbsp;&nbsp;myFile.open("r");<br>
&nbsp;&nbsp;&nbsp;// <I>... файл используется ...

<br></I>&nbsp;&nbsp;&nbsp;myFile.close();<br>
&nbsp;&nbsp;&nbsp;project.unlock();<br>}</PRE>
<p><A NAME="1029438"></a>
Таким образом, только один пользователь приложения может изменять файл в данный 
момент времени. Для более тонкого управления блокировкой Вы можете создать Ваш 
собственный экземпляр класса <CODE>Lock</CODE> для управления доступом к данному 
файлу. Это описано в разделе <A HREF="sessmgmt.htm#1019260">"Использование Lock-Экземпляров&quot;</A>.</p>
<h4><A NAME="Head2;"></A><A NAME="1003930"></a>Работа с Файлами</h4><hr>
<p><A NAME="1000643"></a>
Класс <CODE>File</CODE> имеет несколько методов, которые можно использовать 
после открытия файла:</p>
<ul><LI><A NAME="1000673"></a>Позиционирование: <CODE>setPosition</CODE>,
<CODE>getPosition</CODE>,<CODE> eof</CODE>. Это методы для установки и получения 
текущей позиции указателя в файле и для определения, не находится ли указатель 
в конце файла.</LI><LI><A NAME="1000595"></a>
Чтение из файла: <CODE>read</CODE>, <CODE>readln</CODE>, <CODE>readByte</CODE>.</LI><LI><A NAME="1001628"></a>
Запись в файл: <CODE>write</CODE>, <CODE>writeln</CODE>,
<CODE>writeByte</CODE>, <CODE>flush</CODE>.</LI><LI><A NAME="1001635"></a>
Конвертация двоичного и текстового форматов: <CODE>byteToString</CODE>,
<CODE>stringToByte</CODE>. Конвертируют одно число в символ и наоборот.</LI><LI><A NAME="1001629"></a>
Информационные методы: <CODE>getLength</CODE>, <CODE>exists</CODE>,
<CODE>error</CODE>,<CODE> clearError</CODE>. Для получения информации о файле и 
для получения и очистки error-статуса.</LI></ul>
<p><A NAME="999938"></a>Эти методы описаны в последующих разделах.</p>
<H4><A NAME="Head3;"></A><A NAME="1017903"></a>Позиционирование Внутри Файла</H4><hr><p><A NAME="1000995"></a>
Физический файл, ассоциированный с <CODE>File</CODE> -объектом, имеет указатель 
текущей позиции в файле. Когда Вы открываете файл, указатель находится в начале 
либо в конце файла, в зависимости от режима, использованного при открытии файла. 
В пустом файле начало и конец файла это одна точка.</p>
<p><A NAME="1003655"></a>Метод <CODE>setPosition</CODE> позиционирует указатель в файле,
возвращая <CODE>true</CODE> при успехе и <CODE>false</CODE> - в ином случае.</p>
<PRE><A NAME="1017914"></a>fileObj.setPosition(position);<br>fileObj.setPosition(position, reference);</PRE>
<p><A NAME="1001124"></a>Здесь <CODE>fileObj</CODE> это <CODE>File</CODE> -объект, <CODE>position</CODE> 
это целое число, указывающее позицию указателя, а <CODE>reference</CODE> 
указывает относительную точку для <CODE>position</CODE> таким образом:</p>
<ul><LI><A NAME="1001147"></a>
0: относительно начала файла</LI><LI><A NAME="1001125"></a>1: относительно 
текущей позиции</LI><LI><A NAME="1001126"></a>2: относительно конца файла</LI><LI><A NAME="1001157"></a>
Иное (или unspecified): относительно начала файла</LI></ul><p><A NAME="1001019"></a>
Метод <CODE>getPosition</CODE> возвращает текущую позицию в файле, где первый 
байт файла это всегда байт 0. Этот метод возвращает -1, если имеется ошибка.</p>
<PRE><A NAME="1001195"></a>fileObj.getPosition();</PRE>
<p><A NAME="1001205"></a>
Метод <CODE>eof</CODE> возвращает <CODE>true</CODE>, если указатель находится в 
конце файла, и
<CODE>false</CODE> - в ином случае. Этот метод возвращает <CODE>true</CODE> 
после первой операции чтения, которая пытается прочесть после конца файла.</p>
<PRE><A NAME="1001208"></a>fileObj.eof();</PRE>
<H4><A NAME="Head3;"></A><A NAME="1000998"></a>Чтение из Файла</H4><hr>
<p><A NAME="1001324"></a>
Используйте методы <CODE>read</CODE>, <CODE>readln</CODE> и <CODE>readByte</CODE> для чтения из файла.</p>
<p><A NAME="1001066"></a>Метод <CODE>read</CODE> читает специфицированное 
количество байтов из файла и возвращает строку.</p>
<PRE><A NAME="1001341"></a>fileObj.read(count);</PRE>
<p><A NAME="1001342"></a>
Здесь <CODE>fileObj</CODE> это <CODE>File</CODE> -объект, а <CODE>count</CODE> 
это целое число, специфицирующее количество байтов для чтения. Если <CODE>count</CODE> 
специфицирует больше байтов, чем осталось в файле,
метод читает до конца файла.</p>
<p><A NAME="1001102"></a>
Метод <CODE>readln</CODE> читает следующую строку файла и возвращает её как строку.</p>
<PRE><A NAME="1001382"></a>fileObj.readln();</PRE><p><A NAME="1002985"></a>
Здесь <CODE>fileObj</CODE> это <CODE>File</CODE> -объект. Символы-разделители строк
(<CODE>\r\n</CODE> в Windows или просто <CODE>\n</CODE> в Unix или Macintosh) не 
включаются в строку. Символ <CODE>\r</CODE> пропускается; <CODE>\n</CODE> определяет действительный конец строки.
Этот компромисс даёт осмысленное поведение на всех платформах.</p>
<p><A NAME="1001068"></a>
Метод <CODE>readByte</CODE> читает следующий байт из файла и возвращает числовое значение следующего байта или -1.</p>
<PRE><A NAME="1001404"></a>fileObj.readByte();</PRE><H4><A NAME="Head3;"></A>
<A NAME="1000999"></a>Запись в Файл</H4><hr>
<p><A NAME="1001423"></a>
Для записи в файл имеются методы <CODE>write</CODE>, <CODE>writeln</CODE>,
<CODE>writeByte</CODE> и <CODE>flush</CODE>.</p>
<p><A NAME="1000003"></a>
Метод <CODE>write</CODE> записывает строку в файл. В случае успеха операции 
возвращает <CODE>true</CODE> и <CODE>false</CODE> - в ином случае.</p>
<PRE><A NAME="1001437"></a>fileObj.write(string);</PRE>
<p><A NAME="1001442"></a>
Здесь <CODE>fileObj</CODE> это <CODE>File</CODE> -объект, в <CODE>string</CODE> 
это строка JavaScript.</p>
<p>
<A NAME="1001484"></a>Метод <CODE>writeln</CODE> записывает сроку в файл и 
вводит последующие <CODE>\n</CODE> (<CODE>\r\n</CODE> в текстовом режиме Windows). 
Возвращает <CODE>true</CODE> при успешном выполнении записи и <CODE>false</CODE> 
- в ином случае.</p>
<PRE><A NAME="1001491"></a>fileObj.writeln(string);</PRE>
<p><A NAME="1001494"></a>
Метод <CODE>writeByte</CODE> записывает байт в файл. Возвращает <CODE>true</CODE> 
в случае успеха и <CODE>false</CODE> - в противном случае.</p>
<PRE><A NAME="1001495"></a>fileObj.writeByte(number);</PRE>
<p><A NAME="1001496"></a>
Здесь <CODE>fileObj</CODE> это <CODE>File</CODE> -объект, а <CODE>number</CODE> 
это число.</p>
<p>
<A NAME="1001906"></a>Когда Вы используете один из этих методов, содержимое 
файла внутренне буферизуется.
Метод <CODE>flush</CODE> записывает буфер в файл на диске. Этот метод возвращает <CODE>true</CODE> 
в случае успеха и <CODE>false</CODE> - в противном случае.</p>
<PRE><A NAME="1001894"></a>fileObj.flush();</PRE><H4><A NAME="Head3;"></A><A NAME="1001659"></a>
Конвертация Данных</H4><hr>
<p><A NAME="1001660"></a>Есть два основных формата файлов : ASCII-текст и 
бинарный.
Методы <CODE>byteToString</CODE> и <CODE>stringToByte</CODE> класса <CODE>File</CODE> 
конвертируют данные этих форматов.</p>
<p><A NAME="1001661"></a>
Метод <CODE>byteToString</CODE> конвертирует число в односимвольную строку. Это
static-метод. Вы можете использовать класс <CODE>File</CODE> сам по себе, а не 
его экземпляр, для вызова этого метода.</p>
<PRE><A NAME="1001662"></a>File.byteToString(number);</PRE>
<p><A NAME="1001663"></a>
Если аргумент - не число, метод возвращает пустую строку.</p>
<p><A NAME="1001664"></a>
Метод <CODE>stringToByte</CODE> конвертирует первый символ своего аргумента, 
строку, в число. Это также static-метод.</p>
<PRE><A NAME="1001665"></a>File.stringToByte(string);</PRE>
<p><A NAME="1001666"></a>
Метод возвращает числовое значение первого символа или 0.</p>
<H4><A NAME="Head3;"></A><A NAME="1001667"></a>Получение Информации о Файле</H4>
<hr>
<p><A NAME="1001668"></a>
Вы можете использовать несколько методов класса <CODE>File</CODE> для получения 
информации о файлах и работы с error-статусом.</p>
<p>
<A NAME="1001669"></a>Метод <CODE>getLength</CODE> возвращает число символов в 
текстовом файле или количество байтов в любом другом файле. Возвращает -1, если 
возникла ошибка.</p>
<PRE><A NAME="1001670"></a>fileObj.getLength();</PRE>
<p><A NAME="1001671"></a>
Метод <CODE>exists</CODE> возвращает <CODE>true</CODE>, если файл существует, и <CODE>false</CODE> 
- в ином случае.</p>
<PRE><A NAME="1001672"></a>fileObj.exists();</PRE>
<p><A NAME="1001673"></a>
Метод <CODE>error</CODE> возвращает статус ошибки или -1, если файл не открыт 
или не может быть открыт. Статус ошибки/error status это ненулевое значение, 
если ошибка возникла, и 0 в ином случае (нет ошибки). Коды статуса ошибки 
зависят от платформы; обратитесь к документации по Вашей ОС.</p>
<PRE><A NAME="1001674"></a>fileObj.error();</PRE>
<p><A NAME="1001675"></a>
Метод <CODE>clearError</CODE> очищает error-статус (значение <CODE>error</CODE>) 
и значение <CODE>eof</CODE>.</p>
<PRE><A NAME="1001676"></a>fileObj.clearError();</PRE>
<h4><A NAME="Head2;"></A><A NAME="1000770"></a>Пример</h4><hr>
<p><A NAME="1018037"></a>
На сервере
Netscape имеется  приложение-образец Viewer. Поскольку это приложение даёт 
возможность просматривать файлы на сервере, оно не устанавливается автоматически.</p>
<p>
<A NAME="1018068"></a>Viewer это хороший пример использования класса <CODE>File</CODE>. 
Если Вы установили это приложение, позаботьтесь об ограничении доступа к нему, 
чтобы неавторизованный пользователь не мог просматривать файлы на сервере.
Об ограничении доступа к приложению см. раздел <A HREF="appdev.htm#1048911">"Публикация 
Приложения&quot;</A>.</p>
<p><A NAME="1010690"></a>
Следующий код из приложения Viewer создаёт экземпляр класса <CODE>File</CODE>,
открывает его для чтения и генерирует HTML, отражающий строки файла, с 
разделительной линией после каждой строки.</p>
<PRE><A NAME="1001710"></a>x = new File("\tmp\names.txt");<br>fileIsOpen = x.open("r");<br>
if (fileIsOpen) {<br>&nbsp;&nbsp;&nbsp;write("file name: " + x + "&lt;BR&gt;");<br>
&nbsp;&nbsp;&nbsp;while (!x.eof()) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line = x.readln();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!x.eof())<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write(line+"&lt;br&gt;");<br>&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;if (x.error() != 0)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write("error
reading file" + "&lt;BR&gt;");<br>&nbsp;&nbsp;&nbsp;x.close();<br>}</PRE>
<H2><A NAME="Working with External Libraries"></A><A NAME="1026725"></a>
Работа с Внешними Библиотеками</H2><hr>
<p><A NAME="1026726"></a>Для взаимодействия с внешними приложениями 
рекомендуется использовать LiveConnect, как описано в <A HREF="lc.htm#1008305">
Главе 14, "LiveConnect. Обзор."</A>. Однако Вы можете также вызывать функции, 
написанные на других языках, таких как C, C++ или Pascal, и скомпилированных в 
библиотеки. Такие функции называются <I>native-функции</I> или <i>внешние 
функции</i>. Библиотеки внешних функций, называемые <i>внешними библиотеками</i>, 
являются библиотеками динамической компоновки/dll в ОС Windows и совместно 
используемыми объектами/shared objects - в ОС Unix.</p>
<BLOCKQUOTE>
<p><A NAME="1026732"></a><b>Важно!</b></p><p><A NAME="1026734"></a>&nbsp;Будьте 
осторожны при использовании внешних функций в Вашем приложении. Внешние 
функции могут нарушить защиту/безопасность, если внешняя программа выполняет 
команды пользователя в командной строке (например, программа, дающая 
возможность войти в ОС, или команды оболочки/shell). Эта функциональность 
опасна, так как хакер может присоединить дополнительные команды, используя 
точку с запятой для присоединения нескольких операторов. Лучше исключить 
использование ввода командной строки, если Вы не проверяете его достаточно жёстко.</p></BLOCKQUOTE>
<p><A NAME="1026736"></a>Внешние функции используются в следующих случаях:</p>
<ul><LI><A NAME="1026737"></a>Если у Вас уже имеются сложные функции, написанные 
на других языках, которые можно использовать в приложении.</LI><LI><A NAME="1026738"></a>
Если приложению нужны функции интенсивных вычислений. Обычно функции,
написанные в native-коде, работают быстрее, чем функции, написанные на языке JavaScript.</LI><LI><A NAME="1026739"></a>
Если приложение должно выполнять задачи, которые невозможно выполнить в JavaScript.</LI></ul>
<p><A NAME="1026740"></a>В директории примеров <CODE>jsaccall</CODE> есть 
несколько исходных и header-файлов, иллюстрирующих вызов функций внешних библиотек из приложения JavaScript.</p>
<p><A NAME="1026741"></a>В Application Manager Вы ассоциируете внешнюю библиотеку с 
 
определённым приложением. Но после того как библиотека ассоциирована с одним 
из приложений, она становится доступной всем другим установленным приложениям.</p>
<p><A NAME="1026743"></a>
Выполните следующие действия для использования библиотеки внешних функций в приложении JavaScript:</p>
<OL><LI><A NAME="1026744"></a>Напишите и скомпилируйте библиотеку внешних 
функций в форме, совместимой с JavaScript. (См. <A HREF="#1026768">"Рекомендации 
по Написанию Внешних Функций&quot;</A>)</LI>.<LI><A NAME="1026748"></a>С помощью Application Manager 
идентифицируйте используемую библиотеку, установив новое приложение или 
изменив параметры установки существующего приложения. После этого все 
приложения на данном сервере смогут вызывать внешние функции этой библиотеки. (См. <A HREF="#1027020">"Идентификация 
Файлов Библиотек&quot;</A>)</LI>.<LI><A NAME="1026752"></a>Рестартуйте сервер, 
чтобы загрузить библиотеку с Вашим приложением. Функции внешней библиотеки 
теперь доступны для всех приложений на этом сервере.</LI><LI><A NAME="1026754"></a>
В вашем приложении используйте функции JavaScript 
<CODE>registerCFunction</CODE> - для идентифицирования вызываемых функций 
библиотеки - и <CODE>callC</CODE> - для вызова этих функций. (См. <A HREF="#1026789">"Регистрация 
Внешних Функций"</A> и
<A HREF="#1026801">"Использование Внешних Функций в JavaScript&quot;</A>)</LI>.<LI><A NAME="1026762"></a>
Рекомпилируйте и рестартуйте Ваше приложение, чтобы изменения вступили в силу.</LI><BLOCKQUOTE><A NAME="1026763"></a>
<b>Важно!</b><p><A NAME="1026764"></a>&nbsp;Вы обязаны рестартовать Ваш 
сервер, чтобы установить библиотеку для использования с приложениями. Вы 
обязаны рестартовать сервер каждый раз после добавления файлов новых 
библиотек или изменения имён файлов библиотек, используемых приложениями.</p>  </BLOCKQUOTE></OL>
<h4><A NAME="Head2;"></A><A NAME="1026768"></a>Рекомендации по Написанию Внешних 
Функций</h4><hr>
<p><A NAME="1026769"></a>
Хотя Вы можете написать внешние библиотеки на любом языке, JavaScript использует 
соглашения языка C по вызову. Ваш код обязан подключать header-файл <CODE> jsaccall.h</CODE>, 
находящийся в директории <CODE>js\samples\jsaccall\</CODE>.</p>
<p>
<A NAME="1026771"></a>Эта директория также содержит исходный код примеров 
приложений, которые вызывают функции C, определённые в <CODE>jsaccall.c</CODE>. 
Просмотрите эти файлы, чтобы найти более конкретные рекомендации по написанию 
функций C для использования с JavaScript.</p>
<p>
<A NAME="1026773"></a>Функции, вызываемые из JavaScript, обязаны быть 
экспортируемыми и обязаны соответствовать этому определению типа:</p>
<PRE><A NAME="1027034"></a>typedef void (*LivewireUserCFunction)<br>&nbsp;&nbsp;&nbsp;(int argc, struct
LivewireCCallData argv[], <br>&nbsp;&nbsp;&nbsp; struct LivewireCCallData* result, pblock* pb,<br>
&nbsp;&nbsp;&nbsp; Session* sn, Request* rq);</PRE><h4><A NAME="Head2;"></A>
<A NAME="1027020"></a>Идентификация Файлов Библиотек</h4><hr>
<p><A NAME="1026778"></a>
Прежде чем Вы сможете запустить приложение, использующее функции внешних 
библиотек, Вы обязаны идентифицировать файлы этих библиотек. Используя Application Manager, 
Вы можете идентифицировать библиотеки, когда Вы устанавливаете приложение (щёлкнув Add) 
или когда модифицируете параметры инсталяции приложения (щёлкнув
Modify). Дополнительно об идентификации файлов библиотек с помощью Application Manager 
см. <A HREF="appdev.htm#1043531">"Установка Нового Приложения&quot;</A>.</p>
<BLOCKQUOTE>
<p><A NAME="1026783"></a><b>Важно!</b></p>
<p><A NAME="1026784"></a>&nbsp;После ввода 
пути к файлам библиотек в Application Manager Вы обязаны рестартовать сервер, 
чтобы изменения вступили в силу. Затем необходимо скомпилировать и рестартовать приложение.</p></BLOCKQUOTE>
<p><A NAME="1026786"></a>После идентификации внешних библиотек с помощью Application Manager 
все приложения, запущенные на данном сервере, могут вызывать функции этих 
библиотек (используя
<CODE>registerCFunction</CODE> и <CODE>callC</CODE>).</p>
<h4><A NAME="Head2;"></A><A NAME="1026789"></a>Регистрация Внешних Функций</h4>
<hr>
<p><A NAME="1026791"></a>
Используйте JavaScript-функцию <CODE>registerCFunction</CODE> для регистрации 
внешней функции для использования с приложением JavaScript. Эта функция имеет 
следующий синтаксис:</p>
<PRE><A NAME="1026792"></a>registerCFunction(JSFunctionName, libraryPath, CFunctionName);</PRE>
<p>
<A NAME="1026793"></a>Здесь <CODE>JSFunctionName</CODE> это имя функции как она 
будет вызываться в JavaScript функцией <CODE>callC</CODE>. Параметр <CODE>libraryPath</CODE> 
это полный путь к библиотеке, использующий соглашения Вашей ОС, а параметр
<CODE>CFunctionName</CODE> это имя C-функции как она определена в библиотеке.
В вызове этого метода Вы обязаны вводить имя точно в указанном регистре, 
указанном в Application Manager, даже в ОС NT.</p>
<BLOCKQUOTE>
<p><B>ПРИМЕЧАНИЕ:</B></p><p><A NAME="1026796"></a>
Backslash (\) это специальный символ в JavaScript, поэтому Вы обязаны использовать 
forward slash (/) или двойной backslash (\\) для отделения Windows-директории и 
имён файлов в <CODE>libraryPath</CODE>.</p></BLOCKQUOTE><p><A NAME="1026797"></a>
Данная функция возвращает <CODE>true</CODE>, если функция зарегистрирована успешно, и
<CODE>false</CODE> - в ином случае. Функция может потерпеть неудачу, если JavaScript 
не сможет найти библиотеку по специфицированному пути или не найдёт 
специфицированную функцию в библиотеке.</p>
<p><A NAME="1026798"></a>
Приложение обязано использовать <CODE>registerCFunction</CODE> для регистрации 
функции, прежде чем сможет использовать
<CODE>callC</CODE> для её вызова. После того как приложение зарегистрировало 
функцию, оно может вызывать эту функцию любое число раз. Хорошим местом для 
регистрации функций является начальная страница приложения.</p>
<h4><A NAME="Head2;"></A><A NAME="1026801"></a>Использование Внешних Функций в JavaScript</h4><hr>
<p><A NAME="1026802"></a>
После того как Ваше приложение зарегистрировало функцию, оно может использовать <CODE>callC</CODE> 
для её вызова. Эта функция имеет следующий синтаксис:</p>
<PRE><A NAME="1026803"></a>callC(JSFunctionName, arguments);</PRE>
<p><A NAME="1026804"></a>
Здесь <CODE>JSFunctionName</CODE> это имя функции, как она была идентифицирована 
с помощью
<CODE>registerCFunction</CODE>, а <CODE>arguments</CODE> это список разделённых 
запятыми аргументов внешней функции. В качестве аргументов могут использоваться 
любые значения JavaScript: строки, числа, булевы значения,
объекты или null. Количество аргументов обязано соответствовать количеству 
необходимых аргументов внешней функции. Хотя Вы можете специфицировать объект JavaScript 
в качестве аргумента, это используется редко,
поскольку объект конвертируется в строку перед передачей внешней функции.</p>
<p><A NAME="1026805"></a>
Эта функция возвращает строковое значение, возвращённое внешней функцией. 
Функция <CODE>callC</CODE> может возвращать только строковые значения.</p>
<p><A NAME="1026807"></a>
Приложение-образец <CODE>jsaccall</CODE> иллюстрирует использование внешних 
функций.
Директория <CODE>jsaccall</CODE> содержит исходный код C (в <CODE>jsaccall.c</CODE>), 
определяющий C-функцию с именем <CODE>mystuff_EchoCCallArguments</CODE>. Эта 
функция принимает любое количество аргументов и возвращает строку, содержащую HTML 
с перечислением аргументов. Это пример иллюстрирует вызов функций
C из приложения JavaScript и возвращаемые значения.</p>
<p><A NAME="1026809"></a>
Чтобы запустить <CODE>jsaccall</CODE>, Вы обязаны скомпилировать <CODE> jsaccall.c</CODE> 
имеющимся у Вас компилятором C. Командные строки для нескольких распространённых 
компиляторов даны в файле в виде комментариев.</p>
<p><A NAME="1026810"></a>
Следующие операторы JavaScript (взятые из <CODE>jsaccall.html</CODE>) 
регистрируют C-функцию как
<CODE>echoCCallArguments</CODE> в JavaScript, вызывают функцию <CODE>echoCCallArguments</CODE>, 
а затем генерируют HTML на основе значения, возвращённого данной функцией.</p>
<PRE><A NAME="1026811"></a>var isRegistered = registerCFunction("echoCCallArguments",<br>
&nbsp;&nbsp;&nbsp;"c:\\mycode\\mystuff.dll", "mystuff_EchoCCallArguments");<br>if (isRegistered == true) {<br>
&nbsp;&nbsp;&nbsp;var returnValue = callC("echoCCallArguments", <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"first arg", <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;42,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;true, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"last arg");<br>
&nbsp;&nbsp;&nbsp;write(returnValue);<br>}<br>else {<br>&nbsp;&nbsp;&nbsp;write("registerCFunction() returned
false, " <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ "check server error log for details")<br>}</PRE>
<p>
<A NAME="1026813"></a>Функция <CODE>echoCCallArguments</CODE> создаёт 
результирующую строку, содержащую HTML, который выводит тип и значение каждого 
переданного ей аргумента JavaScript. Если
<CODE>registerCFunction</CODE> возвращает true, вышеприведённый код генерирует 
такой HTML:</p>
<PRE><A NAME="1026814"></a><CODE>argc = 4&lt;BR&gt;<br>argv[0].tag: string; value = first arg&lt;BR&gt;<br>
argv[1].tag: double; value = 42&lt;BR&gt;<br>argv[2].tag: boolean; value = true&lt;BR&gt;<br>
argv[3].tag: string; value = last arg&lt;BR&gt;</CODE></PRE>
<H2><A NAME="Request and Response Manipulation"></A><A NAME="1020125"></a>
Манипуляции с Запросами и Ответами</H2><hr>
<p><A NAME="1031529"></a>Обычный запрос, высылаемый клиентом на сервер, не имеет content type 
(тип содержимого). Машина выполнения JavaScript автоматически обрабатывает такие запросы.
Однако, если пользователь отправляет форму, то клиент автоматически помещает content type 
в шапку/header, чтобы сообщить серверу, как интерпретировать данные формы. Этот content type обычно
<CODE>application/x-www-form-urlencoded</CODE>. Машина выполнения также 
автоматически обрабатывает запросы с этим content type. В таких ситуациях Вам 
редко нужен прямой доступ к шапкам/header запроса или ответа. Если, однако, Ваше 
приложение использует иной content type, оно обязано уметь работать с шапкой запроса.</p><p><A NAME="1031533"></a>
В свою очередь, типичный ответ сервера клиентку имеет тип содержимого <CODE>text/html</CODE>. 
Машина выполнения автоматически добавляет этот content type в свой ответ. Если 
Вам в ответе  нужен другой content type, Вы обязаны предоставить его сами.</p>
<p><A NAME="1031527"></a>
Для поддержки этих потребностей машина выполнения JavaScript на сервере даёт 
возможность Вашему приложению иметь доступ к
(1) шапке/header любого запроса и к (2) телу запроса, имеющего нестандартный content type.
Вы уже контролируете тело ответа тэгом <CODE>SERVER</CODE> и тэгами HTML.
Функциональность, описанная в этом разделе, даёт также возможность управлять шапкой/header ответа.</p>
<p><A NAME="1025606"></a>Вы можете использовать эту функциональность в различных 
целях. Например, как описано в разделе <A HREF="jsserv.htm#1035266">"Использование 
Кук&quot;</A>, можно осуществлять связь серверных и клиентских процессов с помощью 
кук. Также Вы можете использовать эту функциональность для поддержки выгрузки файлов.</p>
<p><A NAME="1033744"></a>World Wide Web Consortium публикует онлайновую информацию о протоколе HTTP
и о том, что может пересылаться по этому протоколу. См., например,
<EM><A HREF="http://www.w3.org/Protocols/Specs.html" TARGET="_blank">HTTP Specifications and
Drafts</EM></A>.</p>
<h4><A NAME="Head2;"></A><A NAME="1033751"></a>Шапка/Header Запроса</h4><hr>
<p><A NAME="1020332"></a>
Для доступа к парам имя/значение шапки клиентского запроса используйте метод <CODE>httpHeader</CODE> 
объекта <CODE>request</CODE>. Этот метод возвращает объект, чьи свойства и 
значения соответствуют парам имя/значение шапки.</p>
<p><A NAME="1022225"></a>
Например, если запрос содержит куки, <CODE>header["cookie"]</CODE> или
<CODE>header.cookie</CODE> будет его значением. Свойство <CODE>cookie</CODE>, 
содержащее все пары имя/значение этой куки (со значениями, кодированными так, 
как описано в разделе <A HREF="jsserv.htm#1035266">"Использование Кук"</A>), 
обязано разбираться Вашим приложением.</p>
<p><A NAME="1021102"></a>
Следующий код выводит свойства и значения шапки:</p>
<PRE><A NAME="1020144"></a>var header = request.httpHeader();<br>var count = 0;<br>var i;</PRE>
<PRE><A NAME="1023798"></a>for (i in header ) {<br>
&nbsp;&nbsp;&nbsp;write(count + ". " + i + " " + header[i] + "&lt;br&gt;\n");<br>&nbsp;&nbsp;&nbsp;count++;<br>
}</PRE>
<p><A NAME="1020151"></a>Если Вы отправили форму методом <CODE>GET</CODE>, на 
выходе получится примерно так:</p>
<PRE><A NAME="1020152"></a>0. connection Keep-Alive <br>1. user-agent Mozilla/4.0b1 (WinNT; I) <br>
2. host piccolo:2020 <br>3. accept image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*</PRE>
<p>
<A NAME="1020156"></a>Если для отправки формы использован метод <CODE>POST</CODE>, 
вывод будет таким:</p>
<PRE><A NAME="1020157"></a>0. referer http://piccolo:2020/world/hello.html <br>
1. connection Keep-Alive <br>2. user-agent Mozilla/4.0b1 (WinNT; I) <br>3. host piccolo:2020 <br>
4. accept image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */* <br>
5. cookie NETSCAPE_LIVEWIRE.oldname=undefined; NETSCAPE_LIVEWIRE.number=0 <br>
6. content-type multipart/form-data; boundary=---------------------------79741602416605 <br>
7. content-length 208</PRE><h4><A NAME="Head2;"></A><A NAME="1021648"></a>Тело 
Запроса</h4><hr>
<p><A NAME="1021198"></a>
Для нормальных HTML-запросов content type (тип содержимого) запроса будет <CODE>application/x-www-form-urlencoded</CODE>.
После получения запроса с этим content type машина выполнения JavaScript на 
сервере обрабатывает запрос, используя данные из тела запроса. В этой ситуации 
Вы не можете получить прямой доступ к необработанным данным тела запроса. (Конечно, 
Вы можете получить доступ к его содержимому через объекты
<CODE>request</CODE> и <CODE>client</CODE>, сконструированные машиной 
выполнения).</p>
<p>
<A NAME="1021199"></a>Если, однако, запрос имеет любой иной content type, машина 
выполнения не обрабатывает автоматически тело запроса. В этом случае Ваше 
приложение должно определить, что делать с содержимым.</p>
<p><A NAME="1021184"></a>Возможно, другая страница Вашего приложения отправила 
запрос этой странице. Следовательно, Ваше приложение обязано предусматривать 
возможность получения необычного content type и должно знать, как его 
обработать.</p>
<p><A NAME="1021666"></a>Для получения доступа к телу запроса Вы используете 
метод <CODE>getPostData</CODE> объекта <CODE>request</CODE>. Этот метод 
принимает в качестве параметра количество символов тела. Если Вы специфицируете 0, 
тело возвращается целиком. return-значение это строка, содержащая запрошенные 
символы. Если доступных данных нет, метод возвращает пустую строку.</p>
<p><A NAME="1021231"></a>Можно использовать этот метод для получения всех 
символов за один раз или читать участки данных. Представляйте тело запроса как 
поток символов. При чтении Вы можете только продвигаться вперёд; Вы не можете 
читать одни и те же символы несколько раз.</p>
<p><A NAME="1021239"></a>
Чтобы назначить всё тело запроса переменной <CODE>postData</CODE>, можно 
использовать следующий оператор:</p>
<PRE><A NAME="1020168"></a>postData = request.getPostData(0);</PRE>
<p><A NAME="1020172"></a>Если в качестве параметра специфицировано 0, метод 
получает весь запрос. Вы можете точно определить, сколько символов содержится в 
информации, используя свойство <CODE>content-length</CODE> шапки таким образом:</p>
<PRE><A NAME="1024880"></a>length = parseInt(header["content-length"], 10);</PRE>
<p><A NAME="1024881"></a>
Для получения тела запроса небольшими блоками Вы можете специфицировать иной 
параметр. Например, следующий код обрабатывает тело запроса блоками по 20 
символов:</p>
<PRE><A NAME="1021296"></a>var length = parseInt(header["content-length"], 10);<br>var i = 0;</PRE>
<PRE><A NAME="1023808"></a>while (i &lt; length) {<br>&nbsp;&nbsp;&nbsp;postData = request.getPostData(20);<br>
&nbsp;&nbsp;&nbsp;// <I>...обработка postData...
<br></I>&nbsp;&nbsp;&nbsp;i = i + 20;<br>}</PRE>
<p>
<A NAME="1020175"></a>Конечно, такой подход имеет смысл только тогда, когда Вы 
знаете, что блоки состоят из 20 символов информации.</p>
<h4><A NAME="Head2;"></A><A NAME="1020181"></a>Шапка/Header Ответа</h4><hr>
<p><A NAME="1021766"></a>
Если отправляемый клиенту ответ/response использует специальный content type 
(тип содержимого), Вы должны кодировать этот content type в шапке ответа. Машина 
выполнения JavaScript автоматически добавляет content type по умолчанию
(<CODE>text/html</CODE>) в шапку ответа/response header. Если вам необходима 
специальная шапка, Вы обязаны сначала удалить из шапки старый content type по 
умолчанию, а затем уже добавить новый. Это делается при помощи функций
<CODE>addResponseHeader</CODE> и <CODE>deleteResponseHeader</CODE>.</p>
<p>
<A NAME="1021767"></a>Например, если Ваш response использует <CODE>royalairways-format</CODE> 
как специальный
content type, Вы можете специфицировать его так:</p>
<PRE><A NAME="1020542"></a>deleteResponseHeader("content-type");<br>
addResponseHeader("content-type","royalairways-format");</PRE>
<p><A NAME="1021736"></a>
Вы можете использовать функцию <CODE>addResponseHeader</CODE> для добавления в 
шапку ответа любой другой нужной информации.</p>
<BLOCKQUOTE>
<p><A NAME="1021771"></a><b>Важно!</b></p><p><A NAME="1021773"></a>&nbsp;Помните, 
что header отсылается с первой частью ответа/response. Следовательно, 
Вы должны вызывать эти функции раньше в скрипте на каждой странице. В общем, 
Вы должны быть уверены, что header ответа установлен <i>до</i> любого из следующих событий:</p></BLOCKQUOTE>
<ul><LI><A NAME="1021774"></a>Машина выполнения сгенерировала 64KB содержимого для HTML-страницы
(в этой точке буфер вывода автоматически очищается).</LI><LI><A NAME="1021775"></a>
Вы вызываете функцию <CODE>flush</CODE> для очистки буфера вывода.</LI><LI><A NAME="1021776"></a>
Вы вызываете функцию <CODE>redirect</CODE> для изменения клиентских запросов.</LI></ul>
<p><A NAME="1021800"></a>Дополнительно см. разделы <A HREF="jsserv.htm#1035796">"Очистка 
Буфера Вывода" </A> и <A HREF="jsserv.htm#1024580">"Процессинг Времени 
Выполнения на Сервере&quot;</A>.</p><HR><p>
<SUP>1</SUP><A NAME="1029528"></a><font size="1"><a href="http://info.internet.isi.edu:80/in-notes/rfc/files/rfc1341.txt">http://info.internet.isi.edu:80/in-notes/rfc/files/rfc1341.txt</a></font></p>
<h5><a href="contents.htm">Оглавление</a> | <a href="sessmgmt.htm">Назад</a>
| <a href="partlw.htm">Вперёд</a>
| <a href="bklast.htm">Индекс</a></h5>
<hr><P ALIGN=right><FONT SIZE=-2><I>Дата последнего обновления: 29 сентября 1999 г.</I></FONT><P><FONT FACE="PrimaSans BT, Verdana, Sans-Serif" SIZE=-2>
&copy; Copyright © 1999 Sun Microsystems, Inc. Некоторая часть Copyright 
© 1999 Netscape Communications Corp. Все Права Зарезервированы.</FONT>
</BODY></HTML>